<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>libtorrent API Documentation</title>
<meta name="author" content="Arvid Norberg, arvid&#64;libtorrent.org" />
<meta name=viewport content="width=device-width, initial-scale=1">
<script type="text/javascript">
/* <![CDATA[ */
    (function() {
        var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];
        s.type = 'text/javascript';
        s.async = true;
        s.src = 'http://api.flattr.com/js/0.6/load.js?mode=auto';
        t.parentNode.insertBefore(s, t);
    })();
/* ]]> */
</script>
<link rel="stylesheet" href="style.css" type="text/css" />
<link rel="stylesheet" type="text/css" href="rst.css" />
<style type="text/css">
/* Hides from IE-mac \*/
* html pre { height: 1%; }
/* End hide from IE-mac */
</style>
</head>
<body>
<div class="document" id="libtorrent-api-documentation">
    <div id="container">
    <table id="header">
    <tr><td id="orange"></td>
    <td id="logo">libtorrent</td></tr>
    </table>
    <div id="main">
<h1 class="title">libtorrent API Documentation</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Arvid Norberg, <a class="last reference external" href="mailto:arvid&#64;libtorrent.org">arvid&#64;libtorrent.org</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1.0.10</td></tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id55">overview</a></li>
<li><a class="reference internal" href="#things-to-keep-in-mind" id="id56">things to keep in mind</a></li>
<li><a class="reference internal" href="#network-primitives" id="id57">network primitives</a></li>
<li><a class="reference internal" href="#exceptions" id="id58">exceptions</a></li>
<li><a class="reference internal" href="#magnet-links" id="id59">magnet links</a></li>
<li><a class="reference internal" href="#queuing" id="id60">queuing</a></li>
<li><a class="reference internal" href="#fast-resume" id="id61">fast resume</a></li>
<li><a class="reference internal" href="#storage-allocation" id="id62">storage allocation</a></li>
<li><a class="reference internal" href="#http-seeding" id="id63">HTTP seeding</a></li>
<li><a class="reference internal" href="#piece-picker" id="id64">piece picker</a></li>
<li><a class="reference internal" href="#ssl-torrents" id="id65">SSL torrents</a></li>
</ul>
</div>
<div class="section" id="overview">
<h1>overview(概述)</h1>
<p>The interface of libtorrent consists of a few classes. The main class is
the <tt class="docutils literal">session</tt>, it contains the main loop that serves all torrents.</p>
<p><font color="#0000E3">libtorrent 接口包含了一些类. 主要的类是 <tt class="docutils literal">session</tt>, 它包含了主要循环来服务所有的 torrents.</font></p>
<p>The basic usage is as follows:</p>
<p><font color="#0000E3">基本使用方法如下:</font></p>
<ul>
<li><p class="first">construct a <a class="reference external" href="reference-Session.html#session">session</a></p>
</li>
<li><p class="first"><font color="#0000E3">构造一个 <a class="reference external" href="reference-Session.html#session">session</a> 对象</font></p>
</li>
<li><p class="first">load <a class="reference external" href="reference-Session.html#session">session</a> state from settings file (see <a class="reference external" href="reference-Session.html#load_state()">load_state()</a>)</p>
</li>
<li><p class="first"><font color="#0000E3">从配置文件中加载 <a class="reference external" href="reference-Session.html#session">session</a> 状态 (查看 <a class="reference external" href="reference-Session.html#load_state()">load_state()</a>)</font></p>
</li>
<li><p class="first">start extensions (see <a class="reference external" href="reference-Core.html#add_extension()">add_extension()</a>).</p>
</li>
<li><p class="first"><font color="#0000E3">启动扩展 (查看 <a class="reference external" href="reference-Core.html#add_extension()">add_extension()</a>).</font></p>
</li>
<li><p class="first">start DHT, LSD, UPnP, NAT-PMP etc (see <a class="reference external" href="reference-Session.html#start_dht()">start_dht()</a>, <a class="reference external" href="reference-Session.html#start_lsd()">start_lsd()</a>, <a class="reference external" href="reference-Session.html#start_upnp()">start_upnp()</a>
and <a class="reference external" href="reference-Session.html#start_natpmp()">start_natpmp()</a>).</p>
</li>
<li><p class="first"><font color="#0000E3">启动 DHT, LSD, UPnP, NAT-PMP 等等 (查看 <a class="reference external" href="reference-Session.html#start_dht()">start_dht()</a>, <a class="reference external" href="reference-Session.html#start_lsd()">start_lsd()</a>, <a class="reference external" href="reference-Session.html#start_upnp()">start_upnp()</a>
以及 <a class="reference external" href="reference-Session.html#start_natpmp()">start_natpmp()</a>).</font></p>
</li>
<li><p class="first">parse .torrent-files and add them to the <a class="reference external" href="reference-Session.html#session">session</a> (see <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a>,
<a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a> and <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a>)</p>
</li>
<li><p class="first"><font color="#0000E3">解析 .torrent-files 然后添加到 <a class="reference external" href="reference-Session.html#session">session</a> (查看 <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a>,
<a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a> 以及 <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a>)</font></p>
</li>
<li><p class="first">main loop (see <a class="reference external" href="reference-Session.html#session">session</a>)</p>
<li><p class="first"><font color="#0000E3">主要循环 (查看 <a class="reference external" href="reference-Session.html#session">session</a>)</font></p>
<blockquote>
<ul class="simple">
<li>poll for alerts (see <a class="reference external" href="reference-Session.html#wait_for_alert()">wait_for_alert()</a>, <a class="reference external" href="reference-Session.html#pop_alerts()">pop_alerts()</a>)</li>
<li><font color="#0000E3">投递报警事件 (查看 <a class="reference external" href="reference-Session.html#wait_for_alert()">wait_for_alert()</a>, <a class="reference external" href="reference-Session.html#pop_alerts()">pop_alerts()</a>)</font></li>
<li>handle updates to torrents, (see <a class="reference external" href="reference-Alerts.html#state_update_alert">state_update_alert</a>).</li>
<li><font color="#0000E3">处理 torrents 更新, (查看 <a class="reference external" href="reference-Alerts.html#state_update_alert">state_update_alert</a>).</font></li>
<li>handle other alerts, (see <a class="reference external" href="reference-Alerts.html#alert">alert</a>).</li>
<li><font color="#0000E3">处理其他报警事件, (查看 <a class="reference external" href="reference-Alerts.html#alert">alert</a>).</font></li>
<li>query the <a class="reference external" href="reference-Session.html#session">session</a> for information (see <a class="reference external" href="reference-Session.html#status()">session::status()</a>).</li>
<li><font color="#0000E3">查询 <a class="reference external" href="reference-Session.html#session">session</a> 获取相关信息 (查看 <a class="reference external" href="reference-Session.html#status()">session::status()</a>).</font></li>
<li>add and remove torrents from the <a class="reference external" href="reference-Session.html#session">session</a> (<a class="reference external" href="reference-Session.html#remove_torrent()">remove_torrent()</a>)</li>
<li><font color="#0000E3">从 <a class="reference external" href="reference-Session.html#session">session</a> 添加和删除 torrents(<a class="reference external" href="reference-Session.html#remove_torrent()">remove_torrent()</a>)</font></li>
</ul>
</blockquote>
</li>
<li><p class="first">save resume data for all torrent_handles (optional, see
<a class="reference external" href="reference-Core.html#save_resume_data()">save_resume_data()</a>)</p>
</li>
</li>
<li><p class="first"><font color="#0000E3">保存所有 torrent_handles 的恢复数据 (可选项, 查看
<a class="reference external" href="reference-Core.html#save_resume_data()">save_resume_data()</a>)</font></p>
</li>
<li><p class="first">save <a class="reference external" href="reference-Session.html#session">session</a> state (see <a class="reference external" href="reference-Session.html#save_state()">save_state()</a>)</p>
</li>
<li><p class="first"><font color="#0000E3">保存 <a class="reference external" href="reference-Session.html#session">session</a> 状态 (查看 <a class="reference external" href="reference-Session.html#save_state()">save_state()</a>)</font></p>
</li>
<li><p class="first">destruct <a class="reference external" href="reference-Session.html#session">session</a> object</p>
</li>
<li><p class="first"><font color="#0000E3">析构 <a class="reference external" href="reference-Session.html#session">session</a> 对象</font></p>
</li>
</ul>
<p>Each class and function is described in this manual.</p>
<p><font color="#0000E3">每个类和函数在这个手册里面都有说明.</font></p>
<p>For a description on how to create torrent files, see <a class="reference external" href="reference-Create_Torrents.html#create_torrent">create_torrent</a>.</p>
<p><font color="#0000E3">这个说明如何去生成 torrent 文件, 查看 <a class="reference external" href="reference-Create_Torrents.html#create_torrent">create_torrent</a>.</font></p>
</div>
<div class="section" id="things-to-keep-in-mind">
<h1>things to keep in mind(需要谨记的一些东西)</h1>
<p>A common problem developers are facing is torrents stopping without explanation.
Here is a description on which conditions libtorrent will stop your torrents,
how to find out about it and what to do about it.</p>
<p><font color="#0000E3">开发者们面对的一个普遍的问题是 torrents 无缘无故停止了.
以下描述说明了在哪些情况下 libtorrent 会停止你的 torrents,
如何去找出来以及要做什么.</font></p>
<p>Make sure to keep track of the paused state, the error state and the upload
mode of your torrents. By default, torrents are auto-managed, which means
libtorrent will pause them, unpause them, scrape them and take them out
of upload-mode automatically.</p>
<p><font color="#0000E3">确保持续跟踪已暂停状态的, 错误状态的以及上传模式的 torrents. 默认的, torrents 是自动管理的, 这意味着
libtorrent 将暂停它们, 不暂停它们, scrape 它们以及自动将它们脱离上传模式.</font></p>
<p>Whenever a torrent encounters a fatal error, it will be stopped, and the
<tt class="docutils literal"><span class="pre">torrent_status::error</span></tt> will describe the error that caused it. If a torrent
is auto managed, it is scraped periodically and paused or resumed based on
the number of downloaders per seed. This will effectively seed torrents that
are in the greatest need of seeds.</p>
<p><font color="#0000E3">无论何时, 当 torrent 遇到致命错误, 它将会被停止, 然后
<tt class="docutils literal"><span class="pre">torrent_status::error</span></tt> 将描述是何种错误导致的. 如果 torrent
是自动管理的, 会定期地 scrape 以及暂停或者重新开始, 这取决于每个 seed 的 downloaders 数目. 这会有效地做种, 因为这些 torrents 是最需要做种的.</font></p>
<p>If a torrent hits a disk write error, it will be put into upload mode. This
means it will not download anything, but only upload. The assumption is that
the write error is caused by a full disk or write permission errors. If the
torrent is auto-managed, it will periodically be taken out of the upload
mode, trying to write things to the disk again. This means torrent will recover
from certain disk errors if the problem is resolved. If the torrent is not
auto managed, you have to call <a class="reference external" href="reference-Core.html#set_upload_mode()">set_upload_mode()</a> to turn
downloading back on again.</p>
<p><font color="#0000E3">如果 torrent 碰到磁盘写操作错误, 它将进入上传模式. 这意味着
不下载, 只上传. 这个可能是磁盘空间满了或者写入权限有问题造成的错误. 如果
torrent 是自动管理的, 将会定期地脱离上传模式, 尝试再次写入磁盘. 这意味着 torrent 将会从某种磁盘错误中恢复如果问题已经解决的话. 如果 torrent 
不是自动管理的话, 你必须调用 <a class="reference external" href="reference-Core.html#set_upload_mode()">set_upload_mode()</a> 来恢复下载.</font></p>
</div>
<div class="section" id="network-primitives">
<h1>network primitives(网络原语)</h1>
<p>There are a few typedefs in the <tt class="docutils literal">libtorrent</tt> namespace which pulls
in network types from the <tt class="docutils literal">asio</tt> namespace. These are:</p>
<p><font color="#0000E3">在 <tt class="docutils literal">libtorrent</tt> 命名空间下有几个网络类型定义来自 <tt class="docutils literal">asio</tt> 命名空间. 它们是:</font></p>
<pre class="literal-block">
typedef asio::ip::address address;
typedef asio::ip::address_v4 address_v4;
typedef asio::ip::address_v6 address_v6;
using asio::ip::tcp;
using asio::ip::udp;
</pre>
<p>These are declared in the <tt class="docutils literal">&lt;libtorrent/socket.hpp&gt;</tt> header.</p>
<p><font color="#0000E3">这些在 <tt class="docutils literal">&lt;libtorrent/socket.hpp&gt;</tt> 这个头文件里有声明.</font></p>
<p>The <tt class="docutils literal">using</tt> statements will give easy access to:</p>
<p><font color="#0000E3">这些 <tt class="docutils literal">using</tt> 声明可以简单地使用:</font></p>
<pre class="literal-block">
tcp::endpoint
udp::endpoint
</pre>
<p>Which are the endpoint types used in libtorrent. An endpoint is an address
with an associated port.</p>
<p><font color="#0000E3">libtorrent 中使用 endpoint 类型. 一个 endpoint 即绑定端口的一个地址.</font></p>
<p>For documentation on these types, please refer to the <a class="reference external" href="http://asio.sourceforge.net/asio-0.3.8/doc/asio/reference.html">asio documentation</a>.</p>
<p><font color="#0000E3">关于这些类型的文档, 请参考 <a class="reference external" href="http://asio.sourceforge.net/asio-0.3.8/doc/asio/reference.html">asio documentation</a>.</font></p>
</div>
<div class="section" id="exceptions">
<h1>exceptions(异常处理)</h1>
<p>Many functions in libtorrent have two versions, one that throws exceptions on
errors and one that takes an <tt class="docutils literal">error_code</tt> reference which is filled with the
error code on errors.</p>
<p><font color="#0000E3">在 libtorrent 许多函数有两种版本, 一种是遇到错误时会抛出异常
 然后另外一种是使用 <tt class="docutils literal">error_code</tt> 的引用来携带一个错误编码.</font></p>
<p>There is one exception class that is used for errors in libtorrent, it is based
on boost.system's <tt class="docutils literal">error_code</tt> class to carry the error code.</p>
<p><font color="#0000E3">在 libtorrent 中有一个异常类来处理错误, 它基于 boost.system 的 <tt class="docutils literal">error_code</tt> 类并且带有错误编码.</font></p>
<p>For more information, see <a class="reference external" href="reference-Error_Codes.html#libtorrent_exception">libtorrent_exception</a> and <a class="reference external" href="reference-Error_Codes.html#error_code_enum">error_code_enum</a>.</p>
<div class="section" id="translating-error-codes">
<p><font color="#0000E3">更多信息, 查看 <a class="reference external" href="reference-Error_Codes.html#libtorrent_exception">libtorrent_exception</a> 和 <a class="reference external" href="reference-Error_Codes.html#error_code_enum">error_code_enum</a>.</font></p>
<div class="section" id="translating-error-codes">
<h2>translating error codes(翻译错误编码)</h2>
<p>The error_code::message() function will typically return a localized error string,
for system errors. That is, errors that belong to the generic or system category.</p>
<p><font color="#0000E3">这个 error_code::message() 函数通常会返回一个本地化错误字串,
对于系统错误来说. 也就是说, 这些是属于通用的或者系统类别的错误.</font></p>
<p>Errors that belong to the libtorrent error category are not localized however, they
are only available in english. In order to translate libtorrent errors, compare the
error category of the <tt class="docutils literal">error_code</tt> object against <tt class="docutils literal"><span class="pre">libtorrent::get_libtorrent_category()</span></tt>,
and if matches, you know the error code refers to the list above. You can provide
your own mapping from error code to string, which is localized. In this case, you
cannot rely on <tt class="docutils literal"><span class="pre">error_code::message()</span></tt> to generate your strings.</p>
<p><font color="#0000E3">然而 libtorrent 类别的错误没有本地化, 只有英语. 为了翻译 libtorrent 错误, 把 <tt class="docutils literal">error_code</tt> 的错误类别和 <tt class="docutils literal"><span class="pre">libtorrent::get_libtorrent_category()</span></tt> 进行比较,
如果匹配, 你可以获取到这个错误编码对应的上述列表中的信息. 你可以提供自己的错误信息映射表, 而这个表是本地化的. 这样, 你不用依赖 <tt class="docutils literal"><span class="pre">error_code::message()</span></tt> 来生成错误信息.</font></p>
<p>The numeric values of the errors are part of the API and will stay the same, although
new error codes may be appended at the end.</p>
<p><font color="#0000E3">错误编码对应的数值表示是 API 的一部分而且是不变的, 而新增的错误编码会被添加到末尾.</font></p>
<p>Here's a simple example of how to translate error codes:</p>
<p><font color="#0000E3">下面是一个如何进行错误编码翻译的例子:</font></p>
<pre class="code c++ literal-block">
<span class="name">std</span><span class="operator">::</span><span class="name">string</span> <span class="name">error_code_to_string</span><span class="punctuation">(</span><span class="name">boost</span><span class="operator">::</span><span class="name">system</span><span class="operator">::</span><span class="name">error_code</span> <span class="keyword">const</span><span class="operator">&amp;</span> <span class="name">ec</span><span class="punctuation">)</span>
<span class="punctuation">{</span>
        <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">ec</span><span class="punctuation">.</span><span class="name">category</span><span class="punctuation">()</span> <span class="operator">!=</span> <span class="name">libtorrent</span><span class="operator">::</span><span class="name">get_libtorrent_category</span><span class="punctuation">())</span>
        <span class="punctuation">{</span>
                <span class="keyword">return</span> <span class="name">ec</span><span class="punctuation">.</span><span class="name">message</span><span class="punctuation">();</span>
        <span class="punctuation">}</span>
        <span class="comment single">// the error is a libtorrent error
</span>
        <span class="keyword type">int</span> <span class="name">code</span> <span class="operator">=</span> <span class="name">ec</span><span class="punctuation">.</span><span class="name">value</span><span class="punctuation">();</span>
        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword type">char</span> <span class="keyword">const</span><span class="operator">*</span> <span class="name">swedish</span><span class="punctuation">[]</span> <span class="operator">=</span>
        <span class="punctuation">{</span>
                <span class="literal string">&quot;inget fel&quot;</span><span class="punctuation">,</span>
                <span class="literal string">&quot;en fil i torrenten kolliderar med en fil fran en annan torrent&quot;</span><span class="punctuation">,</span>
                <span class="literal string">&quot;hash check misslyckades&quot;</span><span class="punctuation">,</span>
                <span class="literal string">&quot;torrentfilen ar inte en dictionary&quot;</span><span class="punctuation">,</span>
                <span class="literal string">&quot;'info'-nyckeln saknas eller ar korrupt i torrentfilen&quot;</span><span class="punctuation">,</span>
                <span class="literal string">&quot;'info'-faltet ar inte en dictionary&quot;</span><span class="punctuation">,</span>
                <span class="literal string">&quot;'piece length' faltet saknas eller ar korrupt i torrentfilen&quot;</span><span class="punctuation">,</span>
                <span class="literal string">&quot;torrentfilen saknar namnfaltet&quot;</span><span class="punctuation">,</span>
                <span class="literal string">&quot;ogiltigt namn i torrentfilen (kan vara en attack)&quot;</span><span class="punctuation">,</span>
                <span class="comment single">// ... more strings here
</span>        <span class="punctuation">};</span>

        <span class="comment single">// use the default error string in case we don't have it
</span>        <span class="comment single">// in our translated list
</span>        <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">code</span> <span class="operator">&lt;</span> <span class="literal number integer">0</span> <span class="operator">||</span> <span class="name">code</span> <span class="operator">&gt;=</span> <span class="keyword">sizeof</span><span class="punctuation">(</span><span class="name">swedish</span><span class="punctuation">)</span><span class="operator">/</span><span class="keyword">sizeof</span><span class="punctuation">(</span><span class="name">swedish</span><span class="punctuation">[</span><span class="literal number integer">0</span><span class="punctuation">]))</span>
                <span class="keyword">return</span> <span class="name">ec</span><span class="punctuation">.</span><span class="name">message</span><span class="punctuation">();</span>

        <span class="keyword">return</span> <span class="name">swedish</span><span class="punctuation">[</span><span class="name">code</span><span class="punctuation">];</span>
<span class="punctuation">}</span>
</pre>
</div>
</div>
<div class="section" id="magnet-links">
<h1>magnet links(磁力链接)</h1>
<p>Magnet links are URIs that includes an info-hash, a display name and optionally
a tracker url. The idea behind magnet links is that an end user can click on a
link in a browser and have it handled by a bittorrent application, to start a
download, without any .torrent file.</p>
<p><font color="#0000E3">磁力链接是一种包含 info-hash 的 URI, 有一个显示名称以及一个可选的 tracker URL.磁力链接的初衷是当用户在浏览器上点击一个链接时
可以通过 bittorrent 应用来处理, 然后开始下载, 但是不需要 .torrent 文件.</font></p>
<p>The format of the magnet URI is:</p>
<p><font color="#0000E3">磁力链接的 URI 格式如下:</font></p>
<p><strong>magnet:?xt=urn:btih:</strong> <em>Base16 encoded info-hash</em> [ <strong>&amp;dn=</strong> <em>name of download</em> ] [ <strong>&amp;tr=</strong> <em>tracker URL</em> ]*</p>
</div>
<div class="section" id="queuing">
<h1>queuing(排队)</h1>
<p>libtorrent supports <em>queuing</em>. Which means it makes sure that a limited number of
torrents are being downloaded at any given time, and once a torrent is completely
downloaded, the next in line is started.</p>
<p><font color="#0000E3">libtorrent 支持<em>排队</em>. 这意味着可以在任何时候保证正在下载的 torrents 数目得到限制, 一个 torrent 下载完成后, 下一个会加入进来下载.</font></p>
<p>Torrents that are <em>auto managed</em> are subject to the queuing and the active
torrents limits. To make a torrent auto managed, set <tt class="docutils literal">auto_managed</tt> to true
when adding the torrent (see <a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a> and <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a>).</p>
<p><font color="#0000E3"><em>自动管理 </em>的 torrents 受到排队以及活动的 torrents 限制的制约. 要使 torrent 自动管理的话, 在添加 torrent 时设置 <tt class="docutils literal">auto_managed</tt> 为 true
 (查看 <a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a> 和 <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a>).</font></p>
<p>The limits of the number of downloading and seeding torrents are controlled via
<tt class="docutils literal">active_downloads</tt>, <tt class="docutils literal">active_seeds</tt> and <tt class="docutils literal">active_limit</tt> in
<a class="reference external" href="reference-Settings.html#session_settings">session_settings</a>. These limits takes non auto managed torrents into account as
well. If there are more non-auto managed torrents being downloaded than the
<tt class="docutils literal">active_downloads</tt> setting, any auto managed torrents will be queued until
torrents are removed so that the number drops below the limit.</p>
<p><font color="#0000E3">限制正在下载的以及正在做种的 torrents 可以通过
<tt class="docutils literal">active_downloads</tt>, <tt class="docutils literal">active_seeds</tt> 和 <tt class="docutils literal">active_limit</tt> 进行控制, 这些配置参数在
<a class="reference external" href="reference-Settings.html#session_settings">session_settings</a>. 这些限制也会将非自动管理的 torrents 计算在内. 如果有比
<tt class="docutils literal">active_downloads</tt> 设置的更多的非自动管理的 torrents 变成下载的, 任何自动管理的 torrents 将会被排队直到
torrents 被删除然后这个数量降至限制值以下.</font></p>
<p>The default values are 8 active downloads and 5 active seeds.</p>
<p><font color="#0000E3">默认是8个活动下载数以及5个活动做种数.</font></p>
<p>In addition to the downloading and seeding limits, there are limits on <em>actions</em>
torrents perform. The downloading and seeding limits control whether peers are
allowed at all, and if peers are not allowed, torrents are stopped and don't do
anything. If peers are allowed, torrents may:</p>
<p><font color="#0000E3">除了下载和做种的限制, 也有对 torrents <em>actions</em>
上的限制. 下载和做种的限制控制是否 peers 都被允许, 如果不被允许, 将停止 torrents 然后不做任何事情. 如果被允许, torrents 将:</font></p>
<ol class="arabic simple">
<li>announce to trackers (向 trackers announce)</li>
<li>announce to the DHT (向 DHT announce)</li>
<li>announce to local peer discovery (local service discovery) (向本地 peer 发现 announce (本地服务发现))</li>
</ol>
<p>Each of those actions are associated with a cost and hence may need a seprarate
limit. These limits are controlled by <tt class="docutils literal">active_tracker_limit</tt>,
<tt class="docutils literal">active_dht_limit</tt> and <tt class="docutils literal">active_lsd_limit</tt> respectively.</p>
<p><font color="#0000E3">以上每一种操作都有开销, 因此可能需要独立的限制. 这些限制分别由 <tt class="docutils literal">active_tracker_limit</tt>,
<tt class="docutils literal">active_dht_limit</tt> 和 <tt class="docutils literal">active_lsd_limit</tt> 控制.</font></p>
<p>A client that is not concerned about the separate costs of these actions should
set all 3 of these limits to the same value as <tt class="docutils literal">active_limit</tt> (i.e.
the max limit of any active torrent).</p>
<p><font color="#0000E3">客户端不关心每一种操作的单独消耗, 设置这三个值为一样的就行, 这个配置是 <tt class="docutils literal">active_limit</tt> (i.e.
活动的 torrent 总限制数).</font></p>
<p>At a regular interval, torrents are checked if there needs to be any
re-ordering of which torrents are active and which are queued. This interval
can be controlled via <tt class="docutils literal">auto_manage_interval</tt> in <a class="reference external" href="reference-Settings.html#session_settings">session_settings</a>. It defaults
to every 30 seconds.</p>
<p><font color="#0000E3">固定的时间间隔内, torrents 会被检查是否需要重新排序, 然后哪一些活动的 torrents 会被排队. 
	这个时间间隔可以通过 <tt class="docutils literal">auto_manage_interval</tt> 这个参数进行控制, 在 <a class="reference external" href="reference-Settings.html#session_settings">session_settings</a> 中. 默认是30秒.</font></p>
<p>For queuing to work, resume data needs to be saved and restored for all
torrents. See <a class="reference external" href="reference-Core.html#save_resume_data()">save_resume_data()</a>.</p>
<p><font color="#0000E3">为了能让排队起作用, 所有 torrents 需要保存恢复数据以及可以加载这些恢复数据. 查看 <a class="reference external" href="reference-Core.html#save_resume_data()">save_resume_data()</a>.</font></p>
<div class="section" id="downloading">
<h2>downloading(下载)</h2>
<p>Torrents that are currently being downloaded or incomplete (with bytes still to
download) are queued. The torrents in the front of the queue are started to be
actively downloaded and the rest are ordered with regards to their queue
position. Any newly added torrent is placed at the end of the queue. Once a
torrent is removed or turns into a seed, its queue position is -1 and all
torrents that used to be after it in the queue, decreases their position in
order to fill the gap.</p>
<p><font color="#0000E3">下载中的或者说不完整的(还有一些数据需要下载) torrents 在排队. 处于队列前面的 torrents 进入活动下载状态然后剩下的按照它们的队列位置进行排序. 
	任何新增的 torrent 会放在队列的末尾. 一旦有一个
torrent 被删除或者变成种子, 它的队列位置会变成 -1 然后之前所有的排在这个 torrent 之后的 torrents, 位置会减小1来填补这个空缺.</font></p>
<p>The queue positions are always in a sequence without any gaps.</p>
<p><font color="#0000E3">队列位置是连续的, 中间没有空缺的.</font></p>
<p>Lower queue position means closer to the front of the queue, and will be
started sooner than torrents with higher queue positions.</p>
<p><font color="#0000E3">队列位置比较小的意味着在队列中更靠前, 会比队列位置大的更快开始.</font></p>
<p>To query a torrent for its position in the queue, or change its position, see:
<a class="reference external" href="reference-Core.html#queue_position()">queue_position()</a>, <a class="reference external" href="reference-Core.html#queue_position_up()">queue_position_up()</a>, <a class="reference external" href="reference-Core.html#queue_position_down()">queue_position_down()</a>,
<a class="reference external" href="reference-Core.html#queue_position_top()">queue_position_top()</a> and <a class="reference external" href="reference-Core.html#queue_position_bottom()">queue_position_bottom()</a>.</p>
<p><font color="#0000E3">查询 torrent 在队列中的位置, 或者改变它的位置, 查看:
<a class="reference external" href="reference-Core.html#queue_position()">queue_position()</a>, <a class="reference external" href="reference-Core.html#queue_position_up()">queue_position_up()</a>, <a class="reference external" href="reference-Core.html#queue_position_down()">queue_position_down()</a>,
<a class="reference external" href="reference-Core.html#queue_position_top()">queue_position_top()</a> 和 <a class="reference external" href="reference-Core.html#queue_position_bottom()">queue_position_bottom()</a>.</font></p>
</div>
<div class="section" id="seeding">
<h2>seeding(做种)</h2>
<p>Auto managed seeding torrents are rotated, so that all of them are allocated a
fair amount of seeding. Torrents with fewer completed <em>seed cycles</em> are
prioritized for seeding. A seed cycle is completed when a torrent meets either
the share ratio limit (uploaded bytes / downloaded bytes), the share time ratio
(time seeding / time downloaing) or seed time limit (time seeded).</p>
<p><font color="#0000E3">自动管理做种中的 torrents 是轮流的, 这样所有做种中的 torrents 可以得到公平地做种. 
	有更少的完整的 <em>seed cycles</em> 的 torrents 会优先做种. 一个 seed cycle 是一个完整的周期, torrent 达到分享率限制 (已上传字节数 / 已下载字节数), 或者分享时间率限制
(做种时间 / 下载时间) 或者做种时间限制 (已做种多长时间).</font></p>
<p>The relevant settings to control these limits are <tt class="docutils literal">share_ratio_limit</tt>,
<tt class="docutils literal">seed_time_ratio_limit</tt> and <tt class="docutils literal">seed_time_limit</tt> in <a class="reference external" href="reference-Settings.html#session_settings">session_settings</a>.</p>
<p><font color="#0000E3">有一些相关的设置来控制这些限制, 是 <tt class="docutils literal">share_ratio_limit</tt>,
<tt class="docutils literal">seed_time_ratio_limit</tt> 和 <tt class="docutils literal">seed_time_limit</tt>, 在 <a class="reference external" href="reference-Settings.html#session_settings">session_settings</a> 中.</font></p>
</div>
</div>
<div class="section" id="fast-resume">
<h1>fast resume(快速恢复)</h1>
<p>The fast resume mechanism is a way to remember which pieces are downloaded
and where they are put between sessions. You can generate fast resume data by
calling <a class="reference external" href="reference-Core.html#save_resume_data()">save_resume_data()</a> on <a class="reference external" href="reference-Core.html#torrent_handle">torrent_handle</a>. You can
then save this data to disk and use it when resuming the torrent. libtorrent
will not check the piece hashes then, and rely on the information given in the
fast-resume data. The fast-resume data also contains information about which
blocks, in the unfinished pieces, were downloaded, so it will not have to
start from scratch on the partially downloaded pieces.</p>
<p><font color="#0000E3">快速恢复机制, 它是这样一种方式, 记住每次会话下载了哪些分片以及存放在哪里. 你可以通过调用
 <a class="reference external" href="reference-Core.html#save_resume_data()">save_resume_data()</a> 来生成快速恢复数据, 在 <a class="reference external" href="reference-Core.html#torrent_handle">torrent_handle</a> 中. 你可以
将这些数据保存到磁盘然后恢复 torrent 的时候使用. libtorrent
将不再检查这些分片的哈希值, 信任快速恢复数据提供的信息. 快速恢复数据也包含分块信息, 未完成的分片中, 哪一些分块下载完成了, 这样就不必从部分下载完成的分片开始.</font></p>
<p>To use the fast-resume data you simply give it to <a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a> and
<a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a>, and it will skip the time consuming checks. It may have to do
the checking anyway, if the fast-resume data is corrupt or doesn't fit the
storage for that torrent, then it will not trust the fast-resume data and just
do the checking.</p>
<p><font color="#0000E3">使用快速恢复数据的时候你只要简单地将这些数据传给 <a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a> 和
<a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a>, 然后它将跳过耗时的检查. 但也有可能还是需要检查, 如果说快速恢复数据损坏了或者与 torrent 存储不匹配, 这时将不会相信快速恢复数据然后会进行检查.</font></p>
<div class="section" id="file-format">
<h2>file format(文件格式)</h2>
<p>The file format is a bencoded dictionary containing the following fields:</p>
<p><font color="#0000E3">它的文件格式是包含以下字段的一个B编码的字典:</font></p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">file-format</span></tt></td>
<td>string: &quot;libtorrent resume file&quot;</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串值: &quot;libtorrent resume file&quot;</font></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">file-version</span></tt></td>
<td>integer: 1</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值: 1</font></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">info-hash</span></tt></td>
<td>string, the info hash of the torrent this data is saved for.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串值, torrent 对应的 info-hash.</font></td>
</tr>
<tr><td><tt class="docutils literal">blocks per piece</tt></td>
<td>integer, the number of blocks per piece. Must be: piece_size
/ (16 * 1024). Clamped to be within the range [1, 256]. It
is the number of blocks per (normal sized) piece. Usually
each block is 16 * 1024 bytes in size. But if piece size is
greater than 4 megabytes, the block size will increase.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值, 每个分片的分块数目. 是: piece_size
/ (16 * 1024). 在 [1, 256] 这个闭合区间内. 它是每个分片 (常规大小) 的分块数目. 通常
每个分块大小是 16 * 1024 字节. 但是如果分片大小大于4MB, 分块将会变大.</font></td>
</tr>
<tr><td><tt class="docutils literal">pieces</tt></td>
<td>A string with piece flags, one character per piece.
Bit 1 means we have that piece.
Bit 2 means we have verified that this piece is correct.
This only applies when the torrent is in seed_mode.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串值, 包含分片标志位, 每个分片一个字符.
Bit 1 表示有这个分片.
Bit 2 表示这个分片已经通过校验.
seed_mode 模式的 torrent 这两个标志位会被置位.</font></td>
</tr>
<tr><td><tt class="docutils literal">slots</tt></td>
<td><p class="first">list of integers. The list maps slots to piece indices. It
tells which piece is on which slot. If piece index is -2 it
means it is free, that there's no piece there. If it is -1,
means the slot isn't allocated on disk yet. The pieces have
to meet the following requirement:</p>
<p class="last">If there's a slot at the position of the piece index,
the piece must be located in that slot.</p>
</td>
</tr>
<tr><td></td>
<td><p class="first"><font color="#0000E3">整型值列表. 列表的槽位映射到分片索引. 每个分片对应到相应槽位. 
	如果分片索引是 -2 那么意味着空闲, 说明没有分片. 如果是 -1, 说明这个槽位还没在磁盘上申请空间. 分片必须达到以下要求:</p>
<p class="last">如果在分片索引位置上有槽位, 那么这个分片必须放在这个槽位上.</font></p>
</td>
</tr>
<tr><td><tt class="docutils literal">total_uploaded</tt></td>
<td>integer. The number of bytes that have been uploaded in
total for this torrent.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 这个 torrent 已经上传的总字节数.</font></td>
</tr>
<tr><td><tt class="docutils literal">total_downloaded</tt></td>
<td>integer. The number of bytes that have been downloaded in
total for this torrent.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 这个 torrent 已经下载的总字节数.</font></td>
</tr>
<tr><td><tt class="docutils literal">active_time</tt></td>
<td>integer. The number of seconds this torrent has been active.
i.e. not paused.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 这个 torrent 总活动秒数.
i.e. 非暂停状态.</font></td>
</tr>
<tr><td><tt class="docutils literal">seeding_time</tt></td>
<td>integer. The number of seconds this torrent has been active
and seeding.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 这个 torrent 总活动做种秒数.</font></td>
</tr>
<tr><td><tt class="docutils literal">num_seeds</tt></td>
<td>integer. An estimate of the number of seeds on this torrent
when the resume data was saved. This is scrape data or based
on the peer list if scrape data is unavailable.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 当快速恢复数据保存时对种子数目的估算. 这个数据来自于 scrape, 或者基于
peer 列表(如果 scrape 获取不到的话).</font></td>
</tr>
<tr><td><tt class="docutils literal">num_downloaders</tt></td>
<td>integer. An estimate of the number of downloaders on this
torrent when the resume data was last saved. This is used as
an initial estimate until we acquire up-to-date scrape info.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 当快速恢复数据最近一次保存时对下载者数目的估算. 这个作为初始化的估算值直到我们获取到最新的 scrape 信息.</font></td>
</tr>
<tr><td><tt class="docutils literal">upload_rate_limit</tt></td>
<td>integer. In case this torrent has a per-torrent upload rate
limit, this is that limit. In bytes per second.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 用在 torrent 有单独的上传速率限制. 单位是 B/s.</font></td>
</tr>
<tr><td><tt class="docutils literal">download_rate_limit</tt></td>
<td>integer. The download rate limit for this torrent in case
one is set, in bytes per second.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 用在 torrent 有单独的下载速率限制, 单位是 B/s.</font></td>
</tr>
<tr><td><tt class="docutils literal">max_connections</tt></td>
<td>integer. The max number of peer connections this torrent
may have, if a limit is set.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 这个 torrent 的 peer 连接数限制, 如果有设置限制的话.</font></td>
</tr>
<tr><td><tt class="docutils literal">max_uploads</tt></td>
<td>integer. The max number of unchoked peers this torrent may
have, if a limit is set.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 这个 torrent 的 unchoked peers 数目限制, 如果有设置限制的话.</font></td>
</tr>
<tr><td><tt class="docutils literal">seed_mode</tt></td>
<td>integer. 1 if the torrent is in seed mode, 0 otherwise.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 1 表示 torrent 处于做种状态, 否则为 0.</font></td>
</tr>
<tr><td><tt class="docutils literal">priority</tt></td>
<td>integer. The priority of a torrent determines how much
bandwidth its peers are assigned when distributing upload
and download rate quotas.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. Torrent 的优先级决定了分发时给 peers 分配多少上传速率带宽配额和下载速率带宽配额.</font></td>
</tr>
<tr><td><tt class="docutils literal">file_priority</tt></td>
<td>list of integers. One entry per file in the torrent. Each
entry is the priority of the file with the same index.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值列表. 在 torrent 中每个文件对应一个记录. 每个记录对应有相同索引的文件的优先级.</font></td>
</tr>
<tr><td><tt class="docutils literal">piece_priority</tt></td>
<td>string of bytes. Each byte is interpreted as an integer and
is the priority of that piece.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字节型字符串. 每个字节看作是一个整型值然后它表示对应分片的优先级.</font></td>
</tr>
<tr><td><tt class="docutils literal">auto_managed</tt></td>
<td>integer. 1 if the torrent is auto managed, otherwise 0.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 自动管理为 1, 否则为 0.</font></td>
</tr>
<tr><td><tt class="docutils literal">sequential_download</tt></td>
<td>integer. 1 if the torrent is in sequential download mode,
0 otherwise.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 顺序下载模式为 1, 否则为 0.</font></td>
</tr>
<tr><td><tt class="docutils literal">paused</tt></td>
<td>integer. 1 if the torrent is paused, 0 otherwise.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">整型值. 暂停为 1, 否则为 0.</font></td>
</tr>
<tr><td><tt class="docutils literal">trackers</tt></td>
<td>list of lists of strings. The top level list lists all
tracker tiers. Each second level list is one tier of
trackers.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串列表的列表. 一级列表列出所有的 tracker tiers. 每个二级列表是 trackers 的其中一个 tier.</font></td>
</tr>
<tr><td><tt class="docutils literal">mapped_files</tt></td>
<td>list of strings. If any file in the torrent has been
renamed, this entry contains a list of all the filenames.
In the same order as in the torrent file.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串列表. 这个 torrent 的任何被重命名的文件, 这个列表包含所有的文件名.
与 torrent 文件中的顺序一样.</font></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">url-list</span></tt></td>
<td>list of strings. List of url-seed URLs used by this torrent.
The urls are expected to be properly encoded and not contain
any illegal url characters.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串列表. 这个 torrent 所有的 url-seed URL.
这些 URL 需要正确编码并且不包含任何非法的 URL 字符.</font></td>
</tr>
<tr><td><tt class="docutils literal">httpseeds</tt></td>
<td>list of strings. List of httpseed URLs used by this torrent.
The urls are expected to be properly encoded and not contain
any illegal url characters.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串列表. 这个 torrent 所有的 httpseed URL.
这些 URL 需要正确编码并且不包含任何非法的 URL 字符.</font></td>
</tr>
<tr><td><tt class="docutils literal">merkle tree</tt></td>
<td>string. In case this torrent is a merkle torrent, this is a
string containing the entire merkle tree, all nodes,
including the root and all leaves. The tree is not
necessarily complete, but complete enough to be able to send
any piece that we have, indicated by the have bitmask.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串. 用在 merkle torrent, 这是一个包含完整 merkle tree 的字符串, 所有节点,
包括根节点以及所有叶子节点. 它不需要完整, 但是可以发送所拥有的分片, 通过 HAVE 位图.</font></td>
</tr>
<tr><td><tt class="docutils literal">save_path</tt></td>
<td>string. The save path where this torrent was saved. This is
especially useful when moving torrents with move_storage()
since this will be updated.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串. 表示 torrent 存储数据的路径. 当使用 move_storage() 移动 torrents 时特别有用, 因为这个值会被更新.</font></td>
</tr>
<tr><td><tt class="docutils literal">peers</tt></td>
<td>string. This string contains IPv4 and port pairs of peers we
were connected to last session. The endpoints are in compact
representation. 4 bytes IPv4 address followed by 2 bytes
port. Hence, the length of this string should be divisible
by 6.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串. 这个字符串包含在最新的会话中连接上的 peers 的信息(IPv4地址以及对应端口). 这些 endpoints 使用紧凑型表示. 4字节的 IPv4 地址紧接着是2字节
的端口信息. 因此, 字符串的长度可以被6整除.</font></td>
</tr>
<tr><td><tt class="docutils literal">banned_peers</tt></td>
<td>string. This string has the same format as <tt class="docutils literal">peers</tt> but
instead represent IPv4 peers that we have banned.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串. 格式与 <tt class="docutils literal">peers</tt> 相同, 但是表示的是我们 banned 的 peers.</font></td>
</tr>
<tr><td><tt class="docutils literal">peers6</tt></td>
<td>string. This string contains IPv6 and port pairs of peers we
were connected to last session. The endpoints are in compact
representation. 16 bytes IPv6 address followed by 2 bytes
port. The length of this string should be divisible by 18.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串. 这个字符串包含在最新的会话中连接上的 peers 的信息(IPv6地址以及对应端口). 这些 endpoints 使用紧凑型表示. 16字节的 IPv6 地址紧接着是2字节
的端口信息. 因此, 字符串的长度可以被18整除.</font></td>
</tr>
<tr><td><tt class="docutils literal">banned_peers6</tt></td>
<td>string. This string has the same format as <tt class="docutils literal">peers6</tt> but
instead represent IPv6 peers that we have banned.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">字符串. 格式与 <tt class="docutils literal">peers6</tt> 相同, 但是表示的是我们 banned 的 peers.</font></td>
</tr>
<tr><td><tt class="docutils literal">unfinished</tt></td>
<td><p class="first">list of dictionaries. Each dictionary represents an
piece, and has the following layout:</p>
<table border="1" class="last docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">piece</tt></td>
<td>integer, the index of the piece this entry
refers to.</td>
</tr>
<tr><td><tt class="docutils literal">bitmask</tt></td>
<td>string, a binary bitmask representing the
blocks that have been downloaded in this
piece.</td>
</tr>
<tr><td><tt class="docutils literal">adler32</tt></td>
<td>The adler32 checksum of the data in the
blocks specified by <tt class="docutils literal">bitmask</tt>.</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr><td></td>
<td><font color="#0000E3"><p class="first">字典列表. 每个字典代表一个分片, 有以下布局:</p>
<table border="1" class="last docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">piece</tt></td>
<td>整型值, 该记录所指的分片索引.</td>
</tr>
<tr><td><tt class="docutils literal">bitmask</tt></td>
<td>整型值, 一个二进制位图来表示分片已经下载了哪些分块.</td>
</tr>
<tr><td><tt class="docutils literal">adler32</tt></td>
<td>由 <tt class="docutils literal">bitmask</tt> 指定的分块数据的 adler32 校验和.</td>
</tr>
</tbody>
</table>
</font></td>
</tr>
<tr><td><tt class="docutils literal">file sizes</tt></td>
<td>list where each entry corresponds to a file in the file list
in the metadata. Each entry has a list of two values, the
first value is the size of the file in bytes, the second
is the time stamp when the last time someone wrote to it.
This information is used to compare with the files on disk.
All the files must match exactly this information in order
to consider the resume data as current. Otherwise a full
re-check is issued.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">列出每个记录在元数据中的文件列表所对应的文件. 
	每个记录是包含两个值的一个列表, 第一个值是文件大小并以字节数表示, 
第二个值是最后一次写入数据的时间戳.
这个信息用于与磁盘上的实际文件比较.
要视恢复数据为当前可用的话, 所有的文件都要符合这个信息. 否则将会完全重新检查一次.</font></td>
</tr>
<tr><td><tt class="docutils literal">allocation</tt></td>
<td>The allocation mode for the storage. Can be either <tt class="docutils literal">full</tt>
or <tt class="docutils literal">compact</tt>. If this is full, the file sizes and
timestamps are disregarded. Pieces are assumed not to have
moved around even if the files have been modified after the
last resume data checkpoint.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">存储的分配模式. 可以是 <tt class="docutils literal">full</tt>
或者 <tt class="docutils literal">compact</tt>. 如果是 full, 会忽略文件大小和时间戳. 假设分片没有移动即使在最近一次恢复数据检查时被编辑过.</font></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="storage-allocation">
<h1>storage allocation(存储分配)</h1>
<p>There are two modes in which storage (files on disk) are allocated in libtorrent.</p>
<p><font color="#0000E3">在 libtorrent 中有两种磁盘分配模式.</font></p>
<ol class="arabic simple">
<li>The traditional <em>full allocation</em> mode, where the entire files are filled up
with zeros before anything is downloaded. Files are allocated on demand, the
first time anything is written to them. The main benefit of this mode is that
it avoids creating heavily fragmented files.</li>
<li><font color="#0000E3">传统的 <em>full allocation</em> 模式, 下载之前整个文件以0填充. 文件按需分配, 一开始不会写入任何东西. 
	这种模式的主要好处是避免产生碎片文件.</font></li>
<li>The <em>sparse allocation</em>, sparse files are used, and pieces are downloaded
directly to where they belong. This is the recommended (and default) mode.</li>
<li><font color="#0000E3"><em>sparse allocation</em> 模式, 使用稀疏文件, 然后分片直接下载到相应的位置. 这个是推荐 (而且默认) 的模式.</font></li>
</ol>
<p>In previous versions of libtorrent, a 3rd mode was supported, <em>compact
allocation</em>. Support for this is deprecated and will be removed in future
versions of libtorrent. It's still described in here for completeness.</p>
<p><font color="#0000E3">在早期的 libtorrent 版本中, 支持第三种模式, <em>compact
allocation</em>. 整个支持将会被弃用并且在后续的版本中会移除该支持. 目前这里仍有完整的描述.</font></p>
<p>The allocation mode is selected when a torrent is started. It is passed as an
argument to <a class="reference external" href="reference-Session.html#add_torrent()">session::add_torrent()</a> or <a class="reference external" href="reference-Session.html#async_add_torrent()">session::async_add_torrent()</a>.</p>
<p><font color="#0000E3">Torrent 开始的时候会选择分配模式. 它作为一个参数传给 <a class="reference external" href="reference-Session.html#add_torrent()">session::add_torrent()</a> 或者 <a class="reference external" href="reference-Session.html#async_add_torrent()">session::async_add_torrent()</a>.</font></p>
<p>The decision to use full allocation or compact allocation typically depends on
whether any files have priority 0 and if the filesystem supports sparse files.</p>
<p><font color="#0000E3">决定使用 full 分配模式还是 compact 分配模式取决于是否文件有优先级0然后如果文件系统支持稀疏文件的话.</font></p>
<div class="section" id="sparse-allocation">
<h2>sparse allocation(稀疏分配)</h2>
<p>On filesystems that supports sparse files, this allocation mode will only use
as much space as has been downloaded.</p>
<p><font color="#0000E3">在支持稀疏文件的文件系统上, 这种分配模式是下载多少然后使用多少空间.</font></p>
<p>The main drawback of this mode is that it may create heavily fragmented files.</p>
<p><font color="#0000E3">这种模式的主要缺点是可能会产生大量的碎片文件.</font></p>
<blockquote>
<ul class="simple">
<li>It does not require an allocation pass on startup.</li>
<li><font color="#0000E3">它不需要在启动的时候传递参数.</font></li>
</ul>
</blockquote>
</div>
<div class="section" id="full-allocation">
<h2>full allocation(全额分配)</h2>
<p>When a torrent is started in full allocation mode, the disk-io thread
will make sure that the entire storage is allocated, and fill any gaps with zeros.
It will of course still check for existing pieces and fast resume data. The main
drawbacks of this mode are:</p>
<p><font color="#0000E3">Torrent 以 full 分配模式开始的话, 磁盘 IO 线程会保证分配完整的存储, 然后所有空间以0填充.
当然还是会检查所有存在的分片以及快速恢复数据. 该模式的主要缺点是:</font></p>
<blockquote>
<ul class="simple">
<li>It may take longer to start the torrent, since it will need to fill the files
with zeroes. This delay is linear to the size of the download.</li>
<li><font color="#0000E3">开始 torrent 的时间会花更多, 因为需要给文件填0. 
	这个延迟时间随下载的文件大小线性变化.</font></li>
<li>The download may occupy unnecessary disk space between download sessions.</li>
<li><font color="#0000E3">下载会占用不必要的磁盘空间.</font></li>
<li>Disk caches usually perform poorly with random access to large files
and may slow down the download some.</li>
<li><font color="#0000E3">随机访问大文件的磁盘缓存性能一般会差然后可能会使下载变慢.</font></li>
</ul>
</blockquote>
<p>The benefits of this mode are:</p>
<p><font color="#0000E3">这种模式的好处是:</font></p>
<blockquote>
<ul class="simple">
<li>Downloaded pieces are written directly to their final place in the files and
the total number of disk operations will be fewer and may also play nicer to
filesystems' file allocation, and reduce fragmentation.</li>
<li><font color="#0000E3">下载的分片直接文件中的最终位置然后整个的磁盘操作会变少, 可能对文件系统的文件分配更友好, 减少碎片.</font></li>
<li>No risk of a download failing because of a full disk during download, once
all files have been created.</li>
<li><font color="#0000E3">没有下载失败的风险因为下载时已经分配了完整的磁盘空间, 当所有文件创建的时候.</font></li>
</ul>
</blockquote>
</div>
<div class="section" id="compact-allocation">
<h2>compact allocation(紧凑分配)</h2>
<div class="note">
<p class="first admonition-title">Note(注意)</p>
<p class="last">Note that support for compact allocation is deprecated in libttorrent, and will
be removed in future versions.</p>
<p class="last"><font color="#0000E3">该模式已弃用, 后续版本会移除该支持.</font></p>
</div>
<p>The compact allocation will only allocate as much storage as it needs to keep
the pieces downloaded so far. This means that pieces will be moved around to be
placed at their final position in the files while downloading (to make sure the
completed download has all its pieces in the correct place). So, the main
drawbacks are:</p>
<p><font color="#0000E3">这个 compact 分配模式只会分配当前已下载的分片的存储. 
	这意味着分片在下载的时候会被移动到它在文件中的最终位置 (确保下载完成时每个分片的位置正确). 也就是说, 主要缺点是:</font></p>
<blockquote>
<ul class="simple">
<li>More disk operations while downloading since pieces are moved around.</li>
<li><font color="#0000E3">因为分片在下载时会被移动, 所以需要更多的磁盘操作.</font></li>
<li>Potentially more fragmentation in the filesystem.</li>
<li><font color="#0000E3">可能在文件系统上产生更多的碎片.</font></li>
<li>Cannot be used while having files with priority 0.</li>
<li><font color="#0000E3">文件优先级0的不能使用.</font></li>
</ul>
</blockquote>
<p>The benefits though, are:</p>
<p><font color="#0000E3">好处如下:</font></p>
<blockquote>
<ul class="simple">
<li>No startup delay, since the files don't need allocating.</li>
<li>The download will not use unnecessary disk space.</li>
<li>Disk caches perform much better than in full allocation and raises the
download speed limit imposed by the disk.</li>
<li>Works well on filesystems that don't support sparse files.</li>
</ul>
</blockquote>
<p>The algorithm that is used when allocating pieces and slots isn't very
complicated. For the interested, a description follows.</p>
<p>storing a piece:</p>
<ol class="arabic simple">
<li>let <strong>A</strong> be a newly downloaded piece, with index <strong>n</strong>.</li>
<li>let <strong>s</strong> be the number of slots allocated in the file we're
downloading to. (the number of pieces it has room for).</li>
<li>if <strong>n</strong> &gt;= <strong>s</strong> then allocate a new slot and put the piece there.</li>
<li>if <strong>n</strong> &lt; <strong>s</strong> then allocate a new slot, move the data at
slot <strong>n</strong> to the new slot and put <strong>A</strong> in slot <strong>n</strong>.</li>
</ol>
<p>allocating a new slot:</p>
<ol class="arabic simple">
<li>if there's an unassigned slot (a slot that doesn't
contain any piece), return that slot index.</li>
<li>append the new slot at the end of the file (or find an unused slot).</li>
<li>let <strong>i</strong> be the index of newly allocated slot</li>
<li>if we have downloaded piece index <strong>i</strong> already (to slot <strong>j</strong>) then<ol class="arabic">
<li>move the data at slot <strong>j</strong> to slot <strong>i</strong>.</li>
<li>return slot index <strong>j</strong> as the newly allocated free slot.</li>
</ol>
</li>
<li>return <strong>i</strong> as the newly allocated slot.</li>
</ol>
</div>
</div>
<div class="section" id="http-seeding">
<h1>HTTP seeding</h1>
<p>There are two kinds of HTTP seeding. One with that assumes a smart (and polite)
client and one that assumes a smart server. These are specified in <a class="reference external" href="http://bittorrent.org/beps/bep_0019.html">BEP 19</a>
and <a class="reference external" href="http://bittorrent.org/beps/bep_0017.html">BEP 17</a> respectively.</p>
<p>libtorrent supports both. In the libtorrent source code and API, BEP 19 urls
are typically referred to as <em>url seeds</em> and BEP 17 urls are typically referred
to as <em>HTTP seeds</em>.</p>
<p>The libtorrent implementation of <a class="reference external" href="http://bittorrent.org/beps/bep_0019.html">BEP 19</a> assumes that, if the URL ends with a
slash ('/'), the filename should be appended to it in order to request pieces
from that file. The way this works is that if the torrent is a single-file
torrent, only that filename is appended. If the torrent is a multi-file
torrent, the torrent's name '/' the file name is appended. This is the same
directory structure that libtorrent will download torrents into.</p>
</div>
<div class="section" id="piece-picker">
<h1>piece picker</h1>
<p>The piece picker in libtorrent has the following features:</p>
<ul class="simple">
<li>rarest first</li>
<li>sequential download</li>
<li>random pick</li>
<li>reverse order picking</li>
<li>parole mode</li>
<li>prioritize partial pieces</li>
<li>prefer whole pieces</li>
<li>piece affinity by speed category</li>
<li>piece priorities</li>
</ul>
<div class="section" id="internal-representation">
<h2>internal representation</h2>
<p>It is optimized by, at all times, keeping a list of pieces ordered by rarity,
randomly shuffled within each rarity class. This list is organized as a single
vector of contigous memory in RAM, for optimal memory locality and to eliminate
heap allocations and frees when updating rarity of pieces.</p>
<p>Expensive events, like a peer joining or leaving, are evaluated lazily, since
it's cheaper to rebuild the whole list rather than updating every single piece
in it. This means as long as no blocks are picked, peers joining and leaving is
no more costly than a single peer joining or leaving. Of course the special
cases of peers that have all or no pieces are optimized to not require
rebuilding the list.</p>
</div>
<div class="section" id="picker-strategy">
<h2>picker strategy</h2>
<p>The normal mode of the picker is of course <em>rarest first</em>, meaning pieces that
few peers have are preferred to be downloaded over pieces that more peers have.
This is a fundamental algorithm that is the basis of the performance of
bittorrent. However, the user may set the piece picker into sequential download
mode. This mode simply picks pieces sequentially, always preferring lower piece
indices.</p>
<p>When a torrent starts out, picking the rarest pieces means increased risk that
pieces won't be completed early (since there are only a few peers they can be
downloaded from), leading to a delay of having any piece to offer to other
peers. This lack of pieces to trade, delays the client from getting started
into the normal tit-for-tat mode of bittorrent, and will result in a long
ramp-up time. The heuristic to mitigate this problem is to, for the first few
pieces, pick random pieces rather than rare pieces. The threshold for when to
leave this initial picker mode is determined by
<a class="reference external" href="reference-Settings.html#initial_picker_threshold">session_settings::initial_picker_threshold</a>.</p>
</div>
<div class="section" id="reverse-order">
<h2>reverse order</h2>
<p>An orthogonal setting is <em>reverse order</em>, which is used for <em>snubbed</em> peers.
Snubbed peers are peers that appear very slow, and might have timed out a piece
request. The idea behind this is to make all snubbed peers more likely to be
able to do download blocks from the same piece, concentrating slow peers on as
few pieces as possible. The reverse order means that the most common pieces are
picked, instead of the rarest pieces (or in the case of sequential download,
the last pieces, intead of the first).</p>
</div>
<div class="section" id="parole-mode">
<h2>parole mode</h2>
<p>Peers that have participated in a piece that failed the hash check, may be put
in <em>parole mode</em>. This means we prefer downloading a full piece  from this
peer, in order to distinguish which peer is sending corrupt data. Whether to do
this is or not is controlled by <a class="reference external" href="reference-Settings.html#use_parole_mode">session_settings::use_parole_mode</a>.</p>
<p>In parole mode, the piece picker prefers picking one whole piece at a time for
a given peer, avoiding picking any blocks from a piece any other peer has
contributed to (since that would defeat the purpose of parole mode).</p>
</div>
<div class="section" id="prioritize-partial-pieces">
<h2>prioritize partial pieces</h2>
<p>This setting determines if partially downloaded or requested pieces should
always be preferred over other pieces. The benefit of doing this is that the
number of partial pieces is minimized (and hence the turn-around time for
downloading a block until it can be uploaded to others is minimized). It also
puts less stress on the disk cache, since fewer partial pieces need to be kept
in the cache. Whether or not to enable this is controlled by
<a class="reference external" href="reference-Settings.html#prioritize_partial_pieces">session_settings::prioritize_partial_pieces</a>.</p>
<p>The main benefit of not prioritizing partial pieces is that the rarest first
algorithm gets to have more influence on which pieces are picked. The picker is
more likely to truly pick the rarest piece, and hence improving the performance
of the swarm.</p>
<p>This setting is turned on automatically whenever the number of partial pieces
in the piece picker exceeds the number of peers we're connected to times 1.5.
This is in order to keep the waste of partial pieces to a minimum, but still
prefer rarest pieces.</p>
</div>
<div class="section" id="prefer-whole-pieces">
<h2>prefer whole pieces</h2>
<p>The <em>prefer whole pieces</em> setting makes the piece picker prefer picking entire
pieces at a time. This is used by web connections (both http seeding
standards), in order to be able to coalesce the small bittorrent requests to
larger HTTP requests. This significantly improves performance when downloading
over HTTP.</p>
<p>It is also used by peers that are downloading faster than a certain threshold.
The main advantage is that these peers will better utilize the other peer's
disk cache, by requesting all blocks in a single piece, from the same peer.</p>
<p>This threshold is controlled by <a class="reference external" href="reference-Settings.html#whole_pieces_threshold">session_settings::whole_pieces_threshold</a>.</p>
<p><em>TODO: piece affinity by speed category</em>
<em>TODO: piece priorities</em></p>
</div>
</div>
<div class="section" id="ssl-torrents">
<h1>SSL torrents</h1>
<p>Torrents may have an SSL root (CA) certificate embedded in them. Such torrents
are called <em>SSL torrents</em>. An SSL torrent talks to all bittorrent peers over
SSL. The protocols are layered like this:</p>
<img alt="utp_stack.png" src="utp_stack.png" />
<p>During the SSL handshake, both peers need to authenticate by providing a
certificate that is signed by the CA certificate found in the .torrent file.
These peer certificates are expected to be privided to peers through some other
means than bittorrent. Typically by a peer generating a certificate request
which is sent to the publisher of the torrent, and the publisher returning a
signed certificate.</p>
<p>In libtorrent, <a class="reference external" href="reference-Core.html#set_ssl_certificate()">set_ssl_certificate()</a> in <a class="reference external" href="reference-Core.html#torrent_handle">torrent_handle</a> is used to tell
libtorrent where to find the peer certificate and the private key for it. When
an SSL torrent is loaded, the <a class="reference external" href="reference-Alerts.html#torrent_need_cert_alert">torrent_need_cert_alert</a> is posted to remind the
user to provide a certificate.</p>
<p>A peer connecting to an SSL torrent MUST provide the <em>SNI</em> TLS extension
(server name indication). The server name is the hex encoded info-hash of the
torrent to connect to. This is required for the client accepting the connection
to know which certificate to present.</p>
<p>SSL connections are accepted on a separate socket from normal bittorrent
connections. To pick which port the SSL socket should bind to, set
<a class="reference external" href="reference-Settings.html#ssl_listen">session_settings::ssl_listen</a> to a different port. It defaults to port 4433.
This setting is only taken into account when the normal listen socket is opened
(i.e. just changing this setting won't necessarily close and re-open the SSL
socket). To not listen on an SSL socket at all, set <tt class="docutils literal">ssl_listen</tt> to 0.</p>
<p>This feature is only available if libtorrent is build with openssl support
(<tt class="docutils literal">TORRENT_USE_OPENSSL</tt>) and requires at least openSSL version 1.0, since it
needs SNI support.</p>
<p>Peer certificates must have at least one <em>SubjectAltName</em> field of type
dNSName. At least one of the fields must <em>exactly</em> match the name of the
torrent. This is a byte-by-byte comparison, the UTF-8 encoding must be
identical (i.e. there's no unicode normalization going on). This is the
recommended way of verifying certificates for HTTPS servers according to <a class="reference external" href="http://www.ietf.org/rfc/rfc2818.txt">RFC
2818</a>. Note the difference that for torrents only <em>dNSName</em> fields are taken
into account (not IP address fields). The most specific (i.e. last) <em>Common
Name</em> field is also taken into account if no <em>SubjectAltName</em> did not match.</p>
<p>If any of these fields contain a single asterisk (&quot;*&quot;), the certificate is
considered covering any torrent, allowing it to be reused for any torrent.</p>
<p>The purpose of matching the torrent name with the fields in the peer
certificate is to allow a publisher to have a single root certificate for all
torrents it distributes, and issue separate peer certificates for each torrent.
A peer receiving a certificate will not necessarily be able to access all
torrents published by this root certificate (only if it has a &quot;star cert&quot;).</p>
<div class="section" id="testing">
<h2>testing</h2>
<p>To test incoming SSL connections to an SSL torrent, one can use the following
<em>openssl</em> command:</p>
<pre class="literal-block">
openssl s_client -cert &lt;peer-certificate&gt;.pem -key &lt;peer-private-key&gt;.pem -CAfile \
   &lt;torrent-cert&gt;.pem -debug -connect 127.0.0.1:4433 -tls1 -servername &lt;info-hash&gt;
</pre>
<p>To create a root certificate, the Distinguished Name (<em>DN</em>) is not taken into
account by bittorrent peers. You still need to specify something, but from
libtorrent's point of view, it doesn't matter what it is. libtorrent only makes
sure the peer certificates are signed by the correct root certificate.</p>
<p>One way to create the certificates is to use the <tt class="docutils literal">CA.sh</tt> script that comes
with openssl, like thisi (don't forget to enter a common Name for the
certificate):</p>
<pre class="literal-block">
CA.sh -newca
CA.sh -newreq
CA.sh -sign
</pre>
<p>The torrent certificate is located in <tt class="docutils literal">./demoCA/private/demoCA/cacert.pem</tt>,
this is the pem file to include in the .torrent file.</p>
<p>The peer's certificate is located in <tt class="docutils literal">./newcert.pem</tt> and the certificate's
private key in <tt class="docutils literal">./newkey.pem</tt>.</p>
</div>
</div>

    </div>
    </div>
    <div id="gradient"></div>
    <div id="footer">
    <table>
    <tr>
      <td><a href="index.html">home</a></td>
      <td><a href="http://blog.libtorrent.org">blog</a></td>
      <td><a href="utp.html">uTP</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/libtorrent/">download</a></td>
      <td><a href="reference.html">documentation</a></td>
      <td><a href="dht_store.html">DHT put extension</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/py-libtorrent/">python bindings</a></td>
      <td><a href="features.html">features</a></td>
      <td><a href="dht_sec.html">DHT security extension</a></td>
    </tr>
    <tr>
      <td><a href="http://dir.gmane.org/gmane.network.bit-torrent.libtorrent">mailing list archive</a></td>
      <td><a href="contributing.html">contributing</a></td>
      <td><a href="streaming.html">streaming</a></td>
    </tr>
    <tr>
      <td><a href="http://code.google.com/p/libtorrent/issues/entry">report a bug</a></td>
      <td><a href="building.html">building</a></td>
      <td><a href="bittorrent.pdf">bittorrent slides</a></td>
    </tr>
    </table>
    </div>
    <div id="filler"></div>

</div>
</body>
</html>
