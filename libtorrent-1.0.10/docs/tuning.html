<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>libtorrent manual</title>
<meta name="author" content="Arvid Norberg, arvid&#64;libtorrent.org" />
<meta name=viewport content="width=device-width, initial-scale=1">
<script type="text/javascript">
/* <![CDATA[ */
    (function() {
        var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];
        s.type = 'text/javascript';
        s.async = true;
        s.src = 'http://api.flattr.com/js/0.6/load.js?mode=auto';
        t.parentNode.insertBefore(s, t);
    })();
/* ]]> */
</script>
<link rel="stylesheet" href="style.css" type="text/css" />
<link rel="stylesheet" type="text/css" href="rst.css" />
<style type="text/css">
/* Hides from IE-mac \*/
* html pre { height: 1%; }
/* End hide from IE-mac */
</style>
</head>
<body>
<div class="document" id="libtorrent-manual">
    <div id="container">
    <table id="header">
    <tr><td id="orange"></td>
    <td id="logo">libtorrent</td></tr>
    </table>
    <div id="main">
<h1 class="title">libtorrent manual</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Arvid Norberg, <a class="last reference external" href="mailto:arvid&#64;libtorrent.org">arvid&#64;libtorrent.org</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1.0.10</td></tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#tuning-libtorrent" id="id1">tuning libtorrent</a></li>
<li><a class="reference internal" href="#reducing-memory-footprint" id="id2">reducing memory footprint</a><ul>
<li><a class="reference internal" href="#disable-disk-cache" id="id3">disable disk cache</a></li>
<li><a class="reference internal" href="#remove-torrents" id="id4">remove torrents</a></li>
<li><a class="reference internal" href="#socket-buffer-sizes" id="id5">socket buffer sizes</a></li>
<li><a class="reference internal" href="#peer-list-size" id="id6">peer list size</a></li>
<li><a class="reference internal" href="#send-buffer-watermark" id="id7">send buffer watermark</a></li>
<li><a class="reference internal" href="#optimize-hashing-for-memory-usage" id="id8">optimize hashing for memory usage</a></li>
<li><a class="reference internal" href="#reduce-executable-size" id="id9">reduce executable size</a></li>
<li><a class="reference internal" href="#reduce-statistics" id="id10">reduce statistics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#play-nice-with-the-disk" id="id11">play nice with the disk</a></li>
<li><a class="reference internal" href="#high-performance-seeding" id="id12">high performance seeding</a><ul>
<li><a class="reference internal" href="#file-pool" id="id13">file pool</a></li>
<li><a class="reference internal" href="#disk-cache" id="id14">disk cache</a></li>
<li><a class="reference internal" href="#utp-tcp-mixed-mode" id="id15">uTP-TCP mixed mode</a></li>
<li><a class="reference internal" href="#send-buffer-low-watermark" id="id16">send buffer low watermark</a></li>
<li><a class="reference internal" href="#peers" id="id17">peers</a></li>
<li><a class="reference internal" href="#torrent-limits" id="id18">torrent limits</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scalability" id="id19">scalability</a></li>
<li><a class="reference internal" href="#benchmarking" id="id20">benchmarking</a><ul>
<li><a class="reference internal" href="#disk-metrics" id="id21">disk metrics</a></li>
<li><a class="reference internal" href="#session-stats" id="id22">session stats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#understanding-the-disk-thread" id="id23">understanding the disk thread</a></li>
<li><a class="reference internal" href="#contributions" id="id24">contributions</a></li>
</ul>
</div>
<div class="section" id="tuning-libtorrent">
<h1>tuning libtorrent(libtorrent 调优)</h1>
<p>libtorrent expose most constants used in the bittorrent engine for
customization through the <tt class="docutils literal">session_settings</tt>. This makes it possible to
test and tweak the parameters for certain algorithms to make a client
that fits a wide range of needs. From low memory embedded devices to
servers seeding thousands of torrents. The default settings in libtorrent
are tuned for an end-user bittorrent client running on a normal desktop
computer.</p>
<p><font color="#0000E3">libtorrent 暴露了大部分的在 bittorrent 引擎中使用的常量用于定制, 
	通过 <tt class="docutils literal">session_settings</tt>. 这使得为某种算法测试和调整参数然后使得客户端适用广泛的需求成为可能. 
	从低内存嵌入式设备到做种成千上万的服务器. 在 libtorrent 中默认配置适用于运行在普通桌面计算机上的终端用户的 bittorrent 客户端.</font></p>
<p>This document describes techniques to benchmark libtorrent performance
and how parameters are likely to affect it.</p>
<p><font color="#0000E3">这个文档描述了 libtorrent 性能基准测试的技术以及哪些参数可能有影响.</font></p>
</div>
<div class="section" id="reducing-memory-footprint">
<h1>reducing memory footprint(减少内存占用)</h1>
<p>These are things you can do to reduce the memory footprint of libtorrent. You get
some of this by basing your default <tt class="docutils literal">session_settings</tt> on the <tt class="docutils literal">min_memory_usage()</tt>
setting preset function.</p>
<p><font color="#0000E3">在 libtorrent 中你可以做这些事情来减少内存占用. 根据默认的
 <tt class="docutils literal">session_settings</tt> 的预设函数 <tt class="docutils literal">min_memory_usage()</tt>
的配置你可以知道一些.</font></p>
<p>Keep in mind that lowering memory usage will affect performance, always profile
and benchmark your settings to determine if it's worth the trade-off.</p>
<p><font color="#0000E3">需要记住的是低内存会影响性能, 概括衡量你的配置来确定是否值得妥协.</font></p>
<p>The typical buffer usage of libtorrent, for a single download, with the cache
size set to 256 blocks (256 * 16 kiB = 4 MiB) is:</p>
<p><font color="#0000E3">libtorrent 中典型的缓冲区使用情况 , 对于单个下载, 缓存大小设置为 256 个分块 (256 * 16 kiB = 4 MiB) :</font></p>
<pre class="literal-block">
read cache:      128.6 (2058 kiB)
write cache:     103.5 (1656 kiB)
receive buffers: 7.3   (117 kiB)
send buffers:    4.8   (77 kiB)
hash temp:       0.001 (19 Bytes)
</pre>
<p>The receive buffers is proportional to the number of connections we make, and is
limited by the total number of connections in the session (default is 200).</p>
<p><font color="#0000E3">接收缓冲区和我们创建的连接数成正比, 然后由会话的连接总数所限制 (默认是 200).</font></p>
<p>The send buffers is proportional to the number of upload slots that are allowed
in the session. The default is auto configured based on the observed upload rate.</p>
<p><font color="#0000E3">发送缓冲区和会话中被允许的上传的槽的数目成正比. 
	默认是根据对上传速度的观察自动配置.</font></p>
<p>The read and write cache can be controlled (see section below).</p>
<p><font color="#0000E3">读写缓存可以控制 (查看下面段落).</font></p>
<p>The &quot;hash temp&quot; entry size depends on whether or not hashing is optimized for
speed or memory usage. In this test run it was optimized for memory usage.</p>
<div class="section" id="disable-disk-cache">
<p><font color="#0000E3">&quot;hash temp&quot; 记录的大小根据是否哈希算法有优化速度或者内存使用
. 本次测试优化内存使用.</font></p>
<div class="section" id="disable-disk-cache">
<h2>disable disk cache(禁用磁盘缓存)</h2>
<p>The bulk of the memory libtorrent will use is used for the disk cache. To save
the absolute most amount of memory, you can disable the cache by setting
<tt class="docutils literal"><span class="pre">session_settings::cache_size</span></tt> to 0. You might want to consider using the cache
but just disable caching read operations. You do this by settings
<tt class="docutils literal"><span class="pre">session_settings::use_read_cache</span></tt> to false. This is the main factor in how much
memory will be used by the client. Keep in mind that you will degrade performance
by disabling the cache. You should benchmark the disk access in order to make an
informed trade-off.</p>
<p><font color="#0000E3">libtorrent 会因为使用磁盘缓存而使用大量的内存. 为了节约绝大多数的内存
, 你可以关闭缓存通过设置
<tt class="docutils literal"><span class="pre">session_settings::cache_size</span></tt> 为 0. 你可能会考虑使用缓存但只是禁用读操作的缓存. 
要这么做的话你可以通过设置
<tt class="docutils literal"><span class="pre">session_settings::use_read_cache</span></tt> 为 false. 这是客户端将使用多少内存的主要因素. 
但是要记住的是禁用缓存会降低性能. 你应该参考磁盘的访问来作出明智的权衡.</font></p>
</div>
<div class="section" id="remove-torrents">
<h2>remove torrents(删除 torrents)</h2>
<p>Torrents that have been added to libtorrent will inevitably use up memory, even
when it's paused. A paused torrent will not use any peer connection objects or
any send or receive buffers though. Any added torrent holds the entire .torrent
file in memory, it also remembers the entire list of peers that it's heard about
(which can be fairly long unless it's capped). It also retains information about
which blocks and pieces we have on disk, which can be significant for torrents
with many pieces.</p>
<p><font color="#0000E3">Torrents 加到 libtorrent 后会立即使用到内存, 即使是暂停的
. 不过暂停的 torrent 将不会使用任何 peer 连接对象或者
任何发送或者接收缓冲区. 任何已经添加的 torrent 会保持完整的 .torrent
文件在内存中, 它也会记住它知道的完整的 peers 列表
(这个列表可以很长直到到达上限). 它还会保留那些关于我们自己在磁盘上拥有哪些分片和分块的信息
, 对于有很多分片的 torrents 是有意义的.</font></p>
<p>If you need to minimize the memory footprint, consider removing torrents from
the session rather than pausing them. This will likely only make a difference
when you have a very large number of torrents in a session.</p>
<p><font color="#0000E3">如果你要把内存使用降到最低, 可以考虑从会话中删除 torrents 而不是暂停它们
. 当你在一个会话中有大量的 torrents 这个会不一样.</font></p>
<p>The downside of removing them is that they will no longer be auto-managed. Paused
auto managed torrents are scraped periodically, to determine which torrents are
in the greatest need of seeding, and libtorrent will prioritize to seed those.</p>
<p><font color="#0000E3">删除它们的负面影响是它们不再是自动管理的. 暂停自动管理的
 torrents 会周期性地 scraped, 决定哪些 torrents 做种需求最强烈, 然后 libtorrent 将优先做种这些 torrents.</font></p>
</div>
<div class="section" id="socket-buffer-sizes">
<h2>socket buffer sizes(套接字缓冲区大小)</h2>
<p>You can make libtorrent explicitly set the kernel buffer sizes of all its peer
sockets. If you set this to a low number, you may see reduced throughput, especially
for high latency connections. It is however an opportunity to save memory per
connection, and might be worth considering if you have a very large number of
peer connections. This memory will not be visible in your process, this sets
the amount of kernel memory is used for your sockets.</p>
<p><font color="#0000E3">你可以让 libtorrent 显示地设置所有它的 peer 套接字的内核缓冲区大小. 
	如果你设置一个低的值, 你可以看到吞吐量减少了, 特别是高延迟的连接. 不管怎样这是一个节约每个连接的内存的条件, 
	如果你有大量的 peer 连接的话也许值得考虑
. 这些内存在你的进程中不可见, 这些用于你的套接字的内核内存大小的设置.</font></p>
<p>Change this by setting <tt class="docutils literal"><span class="pre">session_settings::recv_socket_buffer_size</span></tt> and
<tt class="docutils literal"><span class="pre">session_settings::send_socket_buffer_size</span></tt>.</p>
<p><font color="#0000E3">更改这些配置可以通过设置 <tt class="docutils literal"><span class="pre">session_settings::recv_socket_buffer_size</span></tt> 和
<tt class="docutils literal"><span class="pre">session_settings::send_socket_buffer_size</span></tt>.</font></p>
</div>
<div class="section" id="peer-list-size">
<h2>peer list size(peer 列表大小)</h2>
<p>The default maximum for the peer list is 4000 peers. For IPv4 peers, each peer
entry uses 32 bytes, which ends up using 128 kB per torrent. If seeding 4 popular
torrents, the peer lists alone uses about half a megabyte.</p>
<p><font color="#0000E3">默认的最大的 peer 列表大小是 4000 个 peers. 对于 IPv4 peers, 每个 peer
 使用 32 字节, 这样每个 torrent 最多使用 128 kB. 如果做种 4 个热门的
torrents, peer 列表单独使用大约 0.5 MB.</font></p>
<p>The default limit is the same for paused torrents as well, so if you have a
large number of paused torrents (that are popular) it will be even more
significant.</p>
<p><font color="#0000E3">默认限制对于暂停的 torrents 也是一样的, 因此如果你有大量
	暂停的 torrents (那些热门的) 这会变得更有意义.</font></p>
<p>If you're short of memory, you should consider lowering the limit. 500 is probably
enough. You can do this by setting <tt class="docutils literal"><span class="pre">session_settings::max_peerlist_size</span></tt> to
the max number of peers you want in a torrent's peer list. This limit applies per
torrent. For 5 torrents, the total number of peers in peerlists will be 5 times
the setting.</p>
<p><font color="#0000E3">如果你没有足够的内存, 你应该考虑把限制调小. 500 应该已经足够用了. 
	你可以这么做通过设置 <tt class="docutils literal"><span class="pre">session_settings::max_peerlist_size</span></tt> 为
你想要的一个 torrent 的 peer 列表的最大peers数. 这个限制可以应用到每个
torrent. 对于 5 个 torrents, 在 peer 列表中的总的 peers 数目是 5 倍于
设置值.</font></p>
<p>You should also lower the same limit but for paused torrents. It might even make sense
to set that even lower, since you only need a few peers to start up while waiting
for the tracker and DHT to give you fresh ones. The max peer list size for paused
torrents is set by <tt class="docutils literal"><span class="pre">session_settings::max_paused_peerlist_size</span></tt>.</p>
<p><font color="#0000E3">对于暂停的 torrents 你也可以降低同样的限制. 设置更低可能更有意义, 
	因为你只需要少数的 peers 来预热, 在等待 tracker 和 DHT 给你新的 peers 时. 暂停的 torrents 的 peer 列表的最大值通过 <tt class="docutils literal"><span class="pre">session_settings::max_paused_peerlist_size</span></tt> 进行设置.</font></p>
<p>The drawback of lowering this number is that if you end up in a position where
the tracker is down for an extended period of time, your only hope of finding live
peers is to go through your list of all peers you've ever seen. Having a large
peer list will also help increase performance when starting up, since the torrent
can start connecting to peers in parallel with connecting to the tracker.</p>
<p><font color="#0000E3">降低限制的缺点是如果你最终处于 tracker 宕机很长时间的情况下, 
	你只能寄希望于从你现有的 peers 里面找到活动的 peers. 拥有大量的 peer 列表也会提高预热性能, 因为 torrent
可以在连接 tracker 的同时开始连接 peers.</font></p>
</div>
<div class="section" id="send-buffer-watermark">
<h2>send buffer watermark(发送缓冲区水印)</h2>
<p>The send buffer watermark controls when libtorrent will ask the disk I/O thread
to read blocks from disk, and append it to a peer's send buffer.</p>
<p><font color="#0000E3">发送缓冲区水印控制着何时 libtorrent 将请求磁盘 I/O 线程
从磁盘读取分块, 然后添加到 peer 的发送缓冲区.</font></p>
<p>When the send buffer has fewer than or equal number of bytes as
<tt class="docutils literal"><span class="pre">session_settings::send_buffer_watermark</span></tt>, the peer will ask the disk I/O thread
for more data to send. The trade-off here is between wasting memory by having too
much data in the send buffer, and hurting send rate by starving out the socket,
waiting for the disk read operation to complete.</p>
<p><font color="#0000E3">当发送缓冲区 has 少于或者等于
<tt class="docutils literal"><span class="pre">session_settings::send_buffer_watermark</span></tt> 的字节数, peer 将请求磁盘 I/O 线程
发送更多的数据. 这里需要权衡的是在有更多的数据在发送缓冲区中会损耗更多内存, 和通过冷落套接字降低发送速率之间,
等待磁盘读取操作的完成.</font></p>
<p>If your main objective is memory usage and you're not concerned about being able
to achieve high send rates, you can set the watermark to 9 bytes. This will guarantee
that no more than a single (16 kiB) block will be on the send buffer at a time, for
all peers. This is the least amount of memory possible for the send buffer.</p>
<p><font color="#0000E3">如果你的主要目标是内存使用然后你不关心获得高发送速率, 
	你可以设置水印为 9 字节. 这将会确保每次不多于一个 (16 kiB) 分块在发送缓冲区, 对于所有
 peers. 这可能是最小的发送缓冲区内存.</font></p>
<p>You should benchmark your max send rate when adjusting this setting. If you have
a very fast disk, you are less likely see a performance hit.</p>
<p><font color="#0000E3">调整这个设置时你应该基于你的最大发送速率. 如果你有一个非常快的硬盘, 你几乎看不到有性能方面的问题.</font></p>
</div>
<div class="section" id="optimize-hashing-for-memory-usage">
<h2>optimize hashing for memory usage(为内存使用优化哈希算法)</h2>
<p>When libtorrent is doing hash checks of a file, or when it re-reads a piece that
was just completed to verify its hash, there are two options. The default one
is optimized for speed, which allocates buffers for the entire piece, reads in
the whole piece in one read call, then hashes it.</p>
<p><font color="#0000E3">当 libtorrent 对一个文件进行哈希校验时, 或者重新读取一个已经完成的需要校验哈希的分片时, 
	有两种配置项. 一种是优化速度的
, 这会为整个完整的分片分配缓冲区, 在一次读取调用时读进完整的分片, 然后进行哈希.</font></p>
<p>The second option is to optimize for memory usage instead, where a single buffer
is allocated, and the piece is read one block at a time, hashing it as each
block is read from the file. For low memory environments, this latter approach
is recommended. Change this by settings <tt class="docutils literal"><span class="pre">session_settings::optimize_hashing_for_speed</span></tt>
to false. This will significantly reduce peak memory usage, especially for
torrents with very large pieces.</p>
<p><font color="#0000E3">第二种配置是优化内存使用的, 在分配单个缓冲区, 
	然后整个分片每次读取一个分块, 对从文件读取的每个分块进行哈希
. 对于更低内存的环境, 后者更推荐使用
. 改变这些配置通过设置 <tt class="docutils literal"><span class="pre">session_settings::optimize_hashing_for_speed</span></tt>
为 false. 这对减小内存使用的峰值是有意义的, 特别是有大分片的 
torrents.</font></p>
</div>
<div class="section" id="reduce-executable-size">
<h2>reduce executable size(减小可执行程序大小)</h2>
<p>Compilers generally add a significant number of bytes to executables that make use
of C++ exceptions. By disabling exceptions (-fno-exceptions on GCC), you can
reduce the executable size with up to 45%. In order to build without exception
support, you need to patch parts of boost.</p>
<p><font color="#0000E3">编译器通常添加一个有意义的字节数字到可执行中使得可以使用 C++ 异常. 
	通过禁用异常 (-fno-exceptions 在 GCC 中), 你可以将
可执行程序大小减小到 45%. 为了构建无异常版本的支持, 
你需要打部分 boost 的补丁.</font></p>
<p>Also make sure to optimize for size when compiling.</p>
<p><font color="#0000E3">也可以确保编译时对程序大小进行优化.</font></p>
<p>Another way of reducing the executable size is to disable code that isn't used.
There are a number of <tt class="docutils literal">TORRENT_*</tt> macros that control which features are included
in libtorrent. If these macros are used to strip down libtorrent, make sure the same
macros are defined when building libtorrent as when linking against it. If these
are different the structures will look different from the libtorrent side and from
the client side and memory corruption will follow.</p>
<p><font color="#0000E3">另外一种减小可执行程序大小的方式是禁用不使用的源码.
有一些 <tt class="docutils literal">TORRENT_*</tt> 宏来控制可以在 libtorrent 中包含哪些功能. 
如果这些宏用于裁剪 libtorrent, 构建 libtorrent 时确保定义和链接时同样的宏. 如果是不一样的, 
结构上来看 libtorrent 将不同于客户端, 然后内存占用会遵循.</font></p>
<p>One, probably, safe macro to define is <tt class="docutils literal">TORRENT_NO_DEPRECATE</tt> which removes all
deprecated functions and struct members. As long as no deprecated functions are
relied upon, this should be a simple way to eliminate a little bit of code.</p>
<p><font color="#0000E3">有一点, 也许, 安全的宏定义是 <tt class="docutils literal">TORRENT_NO_DEPRECATE</tt>, 移除所有
弃用的函数和结构体成员. 只要没有依赖于弃用的函数, 删除一些函数将会变得很简单.</font></p>
<p>For all available options, see the <a class="reference external" href="building.html">building libtorrent</a> secion.</p>
<p><font color="#0000E3">关于所有可用的配置, 查看 <a class="reference external" href="building.html">building libtorrent</a> 这篇></font></p>
</div>
<div class="section" id="reduce-statistics">
<h2>reduce statistics(减少统计)</h2>
<p>You can save some memory for each connection and each torrent by reducing the
number of separate rates kept track of by libtorrent. If you build with <tt class="docutils literal"><span class="pre">full-stats=off</span></tt>
(or <tt class="docutils literal"><span class="pre">-DTORRENT_DISABLE_FULL_STATS</span></tt>) you will save a few hundred bytes for each
connection and torrent. It might make a difference if you have a very large number
of peers or torrents.</p>
<p><font color="#0000E3">你可以通过减少 libtorrent 单独保持速率的数目来减少每一个连接和每一个 torrent 的内存使用. 如果你以 <tt class="docutils literal"><span class="pre">full-stats=off</span></tt>
(或者 <tt class="docutils literal"><span class="pre">-DTORRENT_DISABLE_FULL_STATS</span></tt>)来构建 libtorrent 的话， 对于每个连接和每个 torrent 你将节约几百个字节的内存使用. 如果你有大量 peers 的 torrent 的话， 那么可能会大有不同.</font></p>
</div>
</div>
<div class="section" id="play-nice-with-the-disk">
<h1>play nice with the disk(对磁盘友好)</h1>
<p>When checking a torrent, libtorrent will try to read as fast as possible from the disk.
The only thing that might hold it back is a CPU that is slow at calculating SHA-1 hashes,
but typically the file checking is limited by disk read speed. Most operating systems
today do not prioritize disk access based on the importance of the operation, this means
that checking a torrent might delay other disk accesses, such as virtual memory swapping
or just loading file by other (interactive) applications.</p>
<p><font color="#0000E3">校验 torrent 时, libtorrent 会尝试尽可能快的从磁盘读取数据.
唯一能阻止这个的是计算 SHA-1 哈希值时 CPU 慢,
但是通常文件校验瓶颈在于磁盘读取速度. 目前大部分的操作系统不会基于操作的重要性来对访问磁盘进行优先级排序, 
这意味着校验 torrent 可能使得其他磁盘访问产生延迟, 例如虚拟内存交换或者只是从其他(不在活动状态的)程序加载文件.</font></p>
<p>In order to play nicer with the disk, and leave some spare time for it to service other
processes that might be of higher importance to the end-user, you can introduce a sleep
between the disc accesses. This is a direct tradeoff between how fast you can check a
torrent and how soft you will hit the disk.</p>
<p><font color="#0000E3">为了更友好的使用磁盘, 然后可以节约出更多的时间来服务那些更重要的终端用户的任务, 你可以在磁盘访问期间加入睡眠
. 在你能够多快的校验一个
torrent 和你将怎么温柔的使用磁盘之间做直接的权衡.</font></p>
<p>You control this by setting the <tt class="docutils literal"><span class="pre">session_settings::file_checks_delay_per_block</span></tt> to greater
than zero. This number is the number of milliseconds to sleep between each read of 16 kiB.</p>
<p><font color="#0000E3">你可以通过设置 <tt class="docutils literal"><span class="pre">session_settings::file_checks_delay_per_block</span></tt> 为大于零的值来控制它. 该数值表示每次读取 16KB 分块数据之间需要睡眠的毫秒数.</font></p>
<p>The sleeps are not necessarily in between each 16 kiB block (it might be read in larger chunks),
but the number will be multiplied by the number of blocks that were read, to maintain the
same semantics.</p>
<p><font color="#0000E3">每次读取 16KB 分块数据之间的睡眠操作不是必要的 (因为可能会读取大块的数据),
只是这个数值会是读取的分块数的倍数, 来保持语义上的一致.</font></p>
</div>
<div class="section" id="high-performance-seeding">
<h1>high performance seeding(高性能做种)</h1>
<p>In the case of a high volume seed, there are two main concerns. Performance and scalability.
This translates into high send rates, and low memory and CPU usage per peer connection.</p>
<p><font color="#0000E3">就大体积的种子而言, 主要有两个因素. 性能和可扩展性.
也就是说高速上传, 以及每个连接低内存占用、低CPU消耗.</font></p>
<div class="section" id="file-pool">
<h2>file pool(文件池)</h2>
<p>libtorrent keeps an LRU file cache. Each file that is opened, is stuck in the cache. The main
purpose of this is because of anti-virus software that hooks on file-open and file close to
scan the file. Anti-virus software that does that will significantly increase the cost of
opening and closing files. However, for a high performance seed, the file open/close might
be so frequent that it becomes a significant cost. It might therefore be a good idea to allow
a large file descriptor cache. Adjust this though <tt class="docutils literal"><span class="pre">session_settings::file_pool_size</span></tt>.</p>
<p><font color="#0000E3">libtorrent 维护着一个 LRU 文件缓存. 每一个打开的文件, 会驻留在这个缓存中. 这么做主要因为病毒防护软件会通过监视文件打开以及关闭来扫描文件. 
  病毒防护软件会严重增加打开以及关闭文件的消耗. 然而, 对于高性能做种, 文件的开关操作是很频繁的，因此这将是一笔不小的开销. 
  因为做一个大的文件描述符缓存也许是个不错的主意. 可以通过 <tt class="docutils literal"><span class="pre">session_settings::file_pool_size</span></tt> 这个参数来调整.</font></p>
<p>Don't forget to set a high rlimit for file descriptors in your process as well. This limit
must be high enough to keep all connections and files open.</p>
<p><font color="#0000E3">同时不要忘记设置一个较大的 rlimit 值用于大量的文件描述符资源消耗. 该限制值必须足够用于保持所有的连接以及打开文件.</font></p>
</div>
<div class="section" id="disk-cache">
<h2>disk cache(磁盘缓存)</h2>
<p>You typically want to set the cache size to as high as possible. The
<tt class="docutils literal"><span class="pre">session_settings::cache_size</span></tt> is specified in 16 kiB blocks. Since you're seeding,
the cache would be useless unless you also set <tt class="docutils literal"><span class="pre">session_settings::use_read_cache</span></tt>
to true.</p>
<p><font color="#0000E3">你通常想尽可能地把缓存设置大一点. 这个缓存大小的参数
<tt class="docutils literal"><span class="pre">session_settings::cache_size</span></tt> 被指定为 16KB 的分块大小. 一旦要做种,
这个缓存不会被用到除非你同时设置 <tt class="docutils literal"><span class="pre">session_settings::use_read_cache</span></tt>
为 true.</font></p>
<p>In order to increase the possibility of read cache hits, set the
<tt class="docutils literal"><span class="pre">session_settings::cache_expiry</span></tt> to a large number. This won't degrade anything as
long as the client is only seeding, and not downloading any torrents.</p>
<p><font color="#0000E3">为了尽可能地增加读取缓存的命中率, 把缓存过期时间参数
<tt class="docutils literal"><span class="pre">session_settings::cache_expiry</span></tt> 设置大一点. 这个不会减少任何东西，因为客户端只是在做种, 
而且没有在下载.</font></p>
<p>In order to increase the disk cache hit rate, you can enable suggest messages based on
what's in the read cache. To do this, set <tt class="docutils literal"><span class="pre">session_settings::suggest_mode</span></tt> to
<tt class="docutils literal"><span class="pre">session_settings::suggest_read_cache</span></tt>. This will send suggest messages to peers
for the most recently used pieces in the read cache. This is especially useful if you
also enable explicit read cache, by settings <tt class="docutils literal"><span class="pre">session_settings::explicit_read_cache</span></tt>
to the number of pieces to keep in the cache. The explicit read cache will make the
disk read cache stick, and not be evicted by cache misses. The explicit read cache
will automatically pull in the rarest pieces in the read cache.</p>
<p><font color="#0000E3">为了增加磁盘缓存命中率, 你可以开启基于读取缓存中的内容的建议模式消息. 可以通过这么做, 设置 <tt class="docutils literal"><span class="pre">session_settings::suggest_mode</span></tt> 为
<tt class="docutils literal"><span class="pre">session_settings::suggest_read_cache</span></tt> 模式. 对于大部分最近使用过的并且在读取缓存中的分片，这将会发送建议消息给 peers
. 如果你同时显示得开启读取缓存的话这个特别有用, 
通过设置 <tt class="docutils literal"><span class="pre">session_settings::explicit_read_cache</span></tt>
为需要保持在缓存中的分片数. 显示地读取缓存会使
磁盘固定读取缓存, 而且就算缓存没有命中也不会被剔除. 显示读取缓存
将自动拉取稀有分片到读取缓存里面来.</font></p>
<p>Assuming that you seed much more data than you can keep in the cache, to a large
numbers of peers (so that the read cache wouldn't be useful anyway), this may be a
good idea.</p>
<p><font color="#0000E3">假如你做种的数据比缓存中更多, 为大量的 peers (这样不管如何读取缓存没有太大用处), 这可能是个好主意.</font></p>
<p>When peers first connect, libtorrent will send them a number of allow-fast messages,
which lets the peers download certain pieces even when they are choked, since peers
are choked by default, this often triggers immediate requests for those pieces. In the
case of using explicit read cache and suggesting those pieces, allowing fast pieces
should be disabled, to not systematically trigger requests for pieces that are not cached
for all peers. You can turn off allow-fast by settings <tt class="docutils literal"><span class="pre">session_settings::allowed_fast_set_size</span></tt>
to 0.</p>
<p><font color="#0000E3">当 peers 首次连接时, libtorrent 将给他们发送一系列的 allow-fast 消息,
这样即使被阻塞的时候也可以让 peers 下载某些分片, 因为 peers
是默认被阻塞的, 这样通常会触发立即请求有些分片. 由于显示使用读取缓存和建议下载有些分片, 允许快速请求分片将被禁用, 
对于所有 peers，为了随机地触发那些没有缓存的分片的请求
. 你可以关闭 allow-fast 通过设置 <tt class="docutils literal"><span class="pre">session_settings::allowed_fast_set_size</span></tt>
为 0.</font></p>
<p>As an alternative to the explicit cache and suggest messages, there's a <em>guided cache</em>
mode. This means the size of the read cache line that's stored in the cache is determined
based on the upload rate to the peer that triggered the read operation. The idea being
that slow peers don't use up a disproportional amount of space in the cache. This
is enabled through <tt class="docutils literal"><span class="pre">session_settings::guided_read_cache</span></tt>.</p>
<p><font color="#0000E3">显示的缓存和建议消息作为可配置项, 有一个 <em>guided cache</em>
模式. 这意味着存储在中的读取缓存的大小的基准线会
根据上传到 peer 的速度来决定触发缓存读取操作. 这样会变成慢速的 peers 不能在缓存中使用不成比例的空间. 这个
 <tt class="docutils literal"><span class="pre">session_settings::guided_read_cache</span></tt> 配置始终会被开起来.</font></p>
<p>In cases where the assumption is that the cache is only used as a read-ahead, and that no
other peer will ever request the same block while it's still in the cache, the read
cache can be set to be <em>volatile</em>. This means that every block that is requested out of
the read cache is removed immediately. This saves a significant amount of cache space
which can be used as read-ahead for other peers. This mode should <strong>never</strong> be combined
with either <tt class="docutils literal">explicit_read_cache</tt> or <tt class="docutils literal">suggest_read_cache</tt>, since those uses opposite
strategies for the read cache. You don't want to on one hand attract peers to request
the same pieces, and on the other hand assume that they won't request the same pieces
and drop them when the first peer requests it. To enable volatile read cache, set
<tt class="docutils literal"><span class="pre">session_settings::volatile_read_cache</span></tt> to true.</p>
<p><font color="#0000E3">假设缓存仅仅只是作为预读取使用的话, 那么没有
其他 peer 会永远请求缓存中相同的分块, 读取缓存可以设置成
 <em>volatile</em>. 这意味着每个分块从缓存中请求完成后会被立即删除. 这可以节约大量的缓存空间
然后可以用于其他 peers 的预读取. 这个模式永远不该 <strong>never</strong> 和
 <tt class="docutils literal">explicit_read_cache</tt> 或者 <tt class="docutils literal">suggest_read_cache</tt> 一起使用, 因为对于读取缓存来说是互相矛盾的策略. 
 你不能一边让 peers 来请求相同的分片, 然后又一边假设他们不会请求相同的分片然后当第一个 peer 请求完这个分片后就丢弃它. 要开启实时读取缓存的功能的话, 可以设置
<tt class="docutils literal"><span class="pre">session_settings::volatile_read_cache</span></tt> 为 true.</font></p>
</div>
<div class="section" id="utp-tcp-mixed-mode">
<h2>uTP-TCP mixed mode(uTP-TCP 混合模式)</h2>
<p>libtorrent supports <a class="reference external" href="utp.html">uTP</a>, which has a delay based congestion controller. In order to
avoid having a single TCP bittorrent connection completely starve out any uTP connection,
there is a mixed mode algorithm. This attempts to detect congestion on the uTP peers and
throttle TCP to avoid it taking over all bandwidth. This balances the bandwidth resources
between the two protocols. When running on a network where the bandwidth is in such an
abundance that it's virtually infinite, this algorithm is no longer necessary, and might
even be harmful to throughput. It is adviced to experiment with the
<tt class="docutils literal"><span class="pre">session_setting::mixed_mode_algorithm</span></tt>, setting it to <tt class="docutils literal"><span class="pre">session_settings::prefer_tcp</span></tt>.
This setting entirely disables the balancing and unthrottles all connections. On a typical
home connection, this would mean that none of the benefits of uTP would be preserved
(the modem's send buffer would be full at all times) and uTP connections would for the most
part be squashed by the TCP traffic.</p>
<p><font color="#0000E3">libtorrent 支持 <a class="reference external" href="utp.html">uTP</a>, 会有基于拥塞控制的延迟. 为了避免
   只有单一的 TCP bittorrent 连接而完全忽略其他任何的 uTP 连接,
所以才有混合模式的算法. 意图在于检测 uTP peers 的拥塞然后
调节 TCP 连接来避免占用所有带宽. 这会在两种协议之间均衡带宽资源. 
当运行在一个实际带宽无限的网络下, 这个算法不再需要了, 甚至可能会影响吞吐量. 
建议对
<tt class="docutils literal"><span class="pre">session_setting::mixed_mode_algorithm</span></tt> 进行测试, 设置为 <tt class="docutils literal"><span class="pre">session_settings::prefer_tcp</span></tt>.
这个设置会完全禁用均衡而且不限制所有链接. 通常在家用宽带的连接上, 
这意味着 uTP 不会有任何好处
(调制解调器的发送缓冲区会一直处于填满状态) 然后 uTP 连接大部分会被 TCP 流量占据.</font></p>
</div>
<div class="section" id="send-buffer-low-watermark">
<h2>send buffer low watermark(低水位的发送缓冲)</h2>
<p>libtorrent uses a low watermark for send buffers to determine when a new piece should
be requested from the disk I/O subsystem, to be appended to the send buffer. The low
watermark is determined based on the send rate of the socket. It needs to be large
enough to not draining the socket's send buffer before the disk operation completes.</p>
<p><font color="#0000E3">libtorrent 使用一个低水位的缓冲区来决定何时从磁盘 I/O 子系统中请求一个新的分片, 
  然后追加到发送缓冲区. 低水位
检测基于套接字的发送速率. 速率要够大以至于在磁盘操作完成之前不会耗尽套接字的发送缓冲区.</font></p>
<p>The watermark is bound to a max value, to avoid buffer sizes growing out of control.
The default max send buffer size might not be enough to sustain very high upload rates,
and you might have to increase it. It's specified in bytes in
<tt class="docutils literal"><span class="pre">session_settings::send_buffer_watermark</span></tt>.</p>
<p><font color="#0000E3">水位一定得是一个最大值, 以避免缓冲区大小增长失控.
默认的最大的发送缓冲区大小可能不够支撑很高的上传速率,
所以你可能不得不增加它的大小. 可以通过
<tt class="docutils literal"><span class="pre">session_settings::send_buffer_watermark</span></tt> 来指定(以字节为单位).</font></p>
</div>
<div class="section" id="peers">
<h2>peers</h2>
<p>First of all, in order to allow many connections, set the global connection limit
high, <tt class="docutils literal"><span class="pre">session::set_max_connections()</span></tt>. Also set the upload rate limit to
infinite, <tt class="docutils literal"><span class="pre">session::set_upload_rate_limit()</span></tt>, passing 0 means infinite.</p>
<p><font color="#0000E3">首先, 为了支持大量连接, 把全局连接限制设置高, 
  <tt class="docutils literal"><span class="pre">session::set_max_connections()</span></tt>. 同时设置上传速率限制为无限大
, <tt class="docutils literal"><span class="pre">session::set_upload_rate_limit()</span></tt>, 传 0 表示无限大.</font></p>
<p>When dealing with a large number of peers, it might be a good idea to have slightly
stricter timeouts, to get rid of lingering connections as soon as possible.</p>
<p><font color="#0000E3">当处理大量 peers 时, 为了尽可能地避免推迟断开的连接，有严格的超时是不错的主意.</font></p>
<p>There are a couple of relevant settings: <tt class="docutils literal"><span class="pre">session_settings::request_timeout</span></tt>,
<tt class="docutils literal"><span class="pre">session_settings::peer_timeout</span></tt> and <tt class="docutils literal"><span class="pre">session_settings::inactivity_timeout</span></tt>.</p>
<p><font color="#0000E3">有一些相关的设置: <tt class="docutils literal"><span class="pre">session_settings::request_timeout</span></tt>,
<tt class="docutils literal"><span class="pre">session_settings::peer_timeout</span></tt> 和 <tt class="docutils literal"><span class="pre">session_settings::inactivity_timeout</span></tt>.</font></p>
<p>For seeds that are critical for a delivery system, you most likely want to allow
multiple connections from the same IP. That way two people from behind the same NAT
can use the service simultaneously. This is controlled by
<tt class="docutils literal"><span class="pre">session_settings::allow_multiple_connections_per_ip</span></tt>.</p>
<p><font color="#0000E3">对于种子，对于一个分发系统而言那是很关键的, 你很有可能会接受来自同一个 IP 的多个连接
. 这样的话两个来自同一个 NAT 的人可以同时地使用服务. 这个通过
<tt class="docutils literal"><span class="pre">session_settings::allow_multiple_connections_per_ip</span></tt> 来控制.</font></p>
<p>In order to always unchoke peers, turn off automatic unchoke
<tt class="docutils literal"><span class="pre">session_settings::auto_upload_slots</span></tt> and set the number of upload slots to a large
number via <tt class="docutils literal"><span class="pre">session::set_max_uploads()</span></tt>, or use -1 (which means infinite).</p>
<p><font color="#0000E3">为了总是疏通 peers, 关闭自动疏通
<tt class="docutils literal"><span class="pre">session_settings::auto_upload_slots</span></tt> 同时设置上传通道数为一个较大的值通过
 <tt class="docutils literal"><span class="pre">session::set_max_uploads()</span></tt>, 或者使用 -1 (意味着无限大).</font></p>
</div>
<div class="section" id="torrent-limits">
<h2>torrent limits(torrent 限制)</h2>
<p>To seed thousands of torrents, you need to increase the <tt class="docutils literal"><span class="pre">session_settings::active_limit</span></tt>
and <tt class="docutils literal"><span class="pre">session_settings::active_seeds</span></tt>.</p>
<p><font color="#0000E3">为了做种成千上万个 torrents, 你需要增加 <tt class="docutils literal"><span class="pre">session_settings::active_limit</span></tt>
和 <tt class="docutils literal"><span class="pre">session_settings::active_seeds</span></tt> 的大小.</font></p>
</div>
</div>
<div class="section" id="scalability">
<h1>scalability(伸缩性)</h1>
<p>In order to make more efficient use of the libtorrent interface when running a large
number of torrents simultaneously, one can use the <tt class="docutils literal"><span class="pre">session::get_torrent_status()</span></tt> call
together with <tt class="docutils literal"><span class="pre">session::refresh_torrent_status()</span></tt>. Keep in mind that every call into
libtorrent that return some value have to block your thread while posting a message to
the main network thread and then wait for a response (calls that don't return any data
will simply post the message and then immediately return). The time this takes might
become significant once you reach a few hundred torrents (depending on how many calls
you make to each torrent and how often). <tt class="docutils literal">get_torrent_status</tt> lets you query the
status of all torrents in a single call. This will actually loop through all torrents
and run a provided predicate function to determine whether or not to include it in
the returned vector. If you have a lot of torrents, you might want to update the status
of only certain torrents. For instance, you might only be interested in torrents that
are being downloaded.</p>
<p><font color="#0000E3">为了更高效地使用 libtorrent 接口来当同时运行大量 torrents, 
  可以使用 <tt class="docutils literal"><span class="pre">session::get_torrent_status()</span></tt> 与 <tt class="docutils literal"><span class="pre">session::refresh_torrent_status()</span></tt> 一起调用. 要记住，每一次调用
libtorrent 然后需要返回某些值， 不得不阻塞你的线程同时投递消息到
网络主线程然后等待响应(那些不必返回任何数据的调用将简单地投递一下消息然后就立即返回了
). 这个时间花费可能会变得重要， 一旦你有几百个 torrents (基于对每个 torrent 的调用频次). 
<tt class="docutils literal">get_torrent_status</tt> 让你在单次调用中查询所有 torrents 的状态. 
这个实际上会轮询所有 torrents
然后执行一个既定的函数来检测是否包含在返回的 vector 里面
. 如果你有大量的 torrents, 你可能想更新指定的某些 torrents 的状态. 
例如, 你只对正在下载的 torrents 感兴趣.</font></p>
<p>The intended use of these functions is to start off by calling <tt class="docutils literal">get_torrent_status</tt>
to get a list of all torrents that match your criteria. Then call <tt class="docutils literal">refresh_torrent_status</tt>
on that list. This will only refresh the status for the torrents in your list, and thus
ignore all other torrents you might be running. This may save a significant amount of
time, especially if the number of torrents you're interested in is small. In order to
keep your list of interested torrents up to date, you can either call <tt class="docutils literal">get_torrent_status</tt>
from time to time, to include torrents you might have become interested in since the last
time. In order to stop refreshing a certain torrent, simply remove it from the list.</p>
<p><font color="#0000E3">这些函数的用途是开始时调用 <tt class="docutils literal">get_torrent_status</tt>
来获取所有的满足你的条件的 torrents 列表. 调用 <tt class="docutils literal">refresh_torrent_status</tt>
作用于刚才那个列表. 这样只会更新你刚才的列表中的 torrent 的状态, 然后忽略其它 torrents. 这会节约大量时间, 
特别是你感兴趣的 torrent 很少的时候. 为了
你感兴趣的 torrents 列表状态最新, 你可以间歇性调用 <tt class="docutils literal">get_torrent_status</tt>
, 来获取你感兴趣的 torrents 的最后一次状态. 想要停止刷新某个 torrent 的话, 只要简单地从列表中移除即可.</font></p>
<p>A more efficient way however, would be to subscribe to status alert notifications, and
update your list based on these alerts. There are alerts for when torrents are added, removed,
paused, resumed, completed etc. Doing this ensures that you only query status for the
minimal set of torrents you are actually interested in.</p>
<p><font color="#0000E3">还有一种更有效的方式, 可以订阅 torrent 状态变更通知, 然后你
可以根据这些通知更新你的列表. 还有其他一些通知消息， 例如 torrents 的添加, 删除,
暂停, 恢复, 完成等. 这样做确保了你只查询你实际感兴趣的 torrents 的状态.</font></p>
</div>
<div class="section" id="benchmarking">
<h1>benchmarking(基准测试)</h1>
<p>There is a bunch of built-in instrumentation of libtorrent that can be used to get an insight
into what it's doing and how well it performs. This instrumentation is enabled by defining
preprocessor symbols when building.</p>
<p><font color="#0000E3">libtorrent 有一系列的自带工具可用于深入了解它在做什么以及性能有多好. 
  这个工具可以在构建的时候通过定义预处理符号来开启.</font></p>
<p>There are also a number of scripts that parses the log files and generates graphs (requires
gnuplot and python).</p>
<p><font color="#0000E3">有一些脚本可以解析日志文件然后生成图片 (需要
gnuplot 和 python).</font></p>
<div class="section" id="disk-metrics">
<h2>disk metrics(磁盘性能度量指标)</h2>
<p>To enable disk I/O instrumentation, define <tt class="docutils literal">TORRENT_DISK_STATS</tt> when building. When built
with this configuration libtorrent will create three log files, measuring various aspects of
the disk I/O. The following table is an overview of these files and what they measure.</p>
<p><font color="#0000E3">要开启磁盘 I/O 工具的话, 可以在构建时定义 <tt class="docutils literal">TORRENT_DISK_STATS</tt>. 构建时
添加这个配置项 libtorrent 将生成三个日志文件, 来全方位衡量磁盘 I/O. 
下表中是对这三个文件所衡量的东西的简要说明.</font></p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">filename</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">disk_io_thread.log</tt></td>
<td>This is a log of which operation the disk I/O thread is
engaged in, with timestamps. This tells you what the thread
is spending its time doing.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">这个是当前繁忙的磁盘 I/O 线程的操作日志, 包括时间戳. 这个会告诉你线程正在花时间做什么.</font></td>
</tr>
<tr><td><tt class="docutils literal">disk_buffers.log</tt></td>
<td>This log keeps track of what the buffers allocated from the
disk buffer pool are used for. There are 5 categories.
receive buffer, send buffer, write cache, read cache and
temporary hash storage. This is key when optimizing memory
usage.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">这个日志时刻跟踪
从磁盘缓冲池申请缓冲空间的情况以及使用类别情况. 有5种类别.
接收缓冲, 发送缓冲, 写入缓存, 读取缓存和
临时哈希存储. 优化内存使用的时候这个很关键.</font></td>
</tr>
<tr><td><tt class="docutils literal">disk_access.log</tt></td>
<td>This is a low level log of read and write operations, with
timestamps and file offsets. The file offsets are byte
offsets in the torrent (not in any particular file, in the
case of a multi-file torrent). This can be used as an
estimate of the physical drive location. The purpose of
this log is to identify the amount of seeking the drive has
to do.</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">这是一个低级的读写操作日志, 包含时间戳
和文件偏移量. 文件偏移量特指 torrent 中的字节偏移量 (不是常规的文件, 因为有多个文件的 torrent 的情况). 这个可用于物理磁盘位置的估算.
这个日志的意图是标记不得不做的磁盘驱动寻道量.</font></td>
</tr>
</tbody>
</table>
<div class="section" id="disk-io-thread-log">
<h3>disk_io_thread.log</h3>
<p>The structure of this log is simple. For each line, there are two columns, a timestamp and
the operation that was started. There is a special operation called <tt class="docutils literal">idle</tt> which means
it looped back to the top and started waiting for new jobs. If there are more jobs to
handle immediately, the <tt class="docutils literal">idle</tt> state is still there, but the timestamp is the same as the
next job that is handled.</p>
<p><font color="#0000E3">日志文件的结构很简单. 每一行, 有两列, 时间戳和
开始的操作. 有种特定的操作叫 <tt class="docutils literal">idle</tt> ，它意味着
回到开始并等待新的任务. 如果更多的任务需要立即处理, 
这个 <tt class="docutils literal">idle</tt> 状态会持续, 但是时间戳和下一个处理的任务相同.</font></p>
<p>Some operations have a 3:rd column with an optional parameter. <tt class="docutils literal">read</tt> and <tt class="docutils literal">write</tt> tells
you the number of bytes that were requested to be read or written. <tt class="docutils literal">flushing</tt> tells you
the number of bytes that were flushed from the disk cache.</p>
<p><font color="#0000E3">有些操作会有第三列， 包括操作参数. <tt class="docutils literal">read</tt> 和 <tt class="docutils literal">write</tt> 说明
需要读取或者写入的字节数. <tt class="docutils literal">flushing</tt> 说明
从磁盘缓存刷到硬盘的字节数.</font></p>
<p>This is an example excerpt from a log:</p>
<p><font color="#0000E3">这是日志文件中的一个例子:</font></p>
<pre class="literal-block">
3702 idle
3706 check_fastresume
3707 idle
4708 save_resume_data
4708 idle
8230 read 16384
8255 idle
8431 read 16384
</pre>
<p>The script to parse this log and generate a graph is called <tt class="docutils literal">parse_disk_log.py</tt>. It takes
the log file as the first command line argument, and produces a file: <tt class="docutils literal">disk_io.png</tt>.
The time stamp is in milliseconds since start.</p>
<p><font color="#0000E3">解析日志文件并生成图片的脚本是 <tt class="docutils literal">parse_disk_log.py</tt>. 它的第一个命令行参数是日志文件, 然后会生成一个文件: <tt class="docutils literal">disk_io.png</tt>.
时间戳是从开始算起的并且以毫秒为单位.</font></p>
<p>You can pass in a second, optional, argument to specify the window size it will average
the time measurements over. The default is 5 seconds. For long test runs, it might be interesting
to increase that number. It is specified as a number of seconds.</p>
<p><font color="#0000E3">你可以传递秒, 可选的, 参数来指定过去测量的平局值的窗口大小. 
  默认值是5秒. 对于长时间运行测试, 需要增加一下这个值. 指定一下秒数.</font></p>
<img alt="disk_io.png" src="disk_io.png" />
<p>This is an example graph generated by the parse script.</p>
<p><font color="#0000E3">这是一个由脚本生成的例图.</font></p>
</div>
<div class="section" id="disk-buffers-log">
<h3>disk_buffers.log</h3>
<p>The disk buffer log tells you where the buffer memory is used. The log format has a time stamp,
the name of the buffer usage which use-count changed, colon, and the new number of blocks that are
in use for this particular key. For example:</p>
<p><font color="#0000E3">磁盘缓冲日志文件说明了缓冲内存用于何处. 它的日志格式有时间戳,
缓冲具体使用量变更的名称, 冒号, 以及具体使用的新的分块数. 例如:</font></p>
<pre class="literal-block">
23671 write cache: 18
23671 receive buffer: 3
24153 receive buffer: 2
24153 write cache: 19
24154 receive buffer: 3
24198 receive buffer: 2
24198 write cache: 20
24202 receive buffer: 3
24305 send buffer: 0
24305 send buffer: 1
24909 receive buffer: 2
24909 write cache: 21
24910 receive buffer: 3
</pre>
<p>The time stamp is in milliseconds since start.</p>
<p><font color="#0000E3">时间戳是从开始算起的并且以毫秒为单位.</font></p>
<p>To generate a graph, use <tt class="docutils literal">parse_disk_buffer_log.py</tt>. It takes the log file as the first
command line argument. It generates <tt class="docutils literal">disk_buffer.png</tt>.</p>
<p><font color="#0000E3">要生成图片的话, 可以使用 <tt class="docutils literal">parse_disk_buffer_log.py</tt>. 它的第一个命令行参数是日志文件. 它可以生成 <tt class="docutils literal">disk_buffer.png</tt>.</font></p>
<img alt="disk_buffer_sample.png" src="disk_buffer_sample.png" />
<p>This is an example graph generated by the parse script.</p>
<p><font color="#0000E3">这是一个由脚本生成的例图.</font></p>
</div>
<div class="section" id="disk-access-log">
<h3>disk_access.log</h3>
<p>The disc access log has three fields. The timestamp (milliseconds since start), operation
and offset. The offset is the absolute offset within the torrent (not within a file). This
log is only useful when you're downloading a single torrent, otherwise the offsets will not
be unique.</p>
<p><font color="#0000E3">磁盘访问日志有三个字段. 时间戳 (从开始算起的毫秒数), 操作
和 偏移量. 偏移量是指 torrent 的绝对偏移量 (不是普通文件). 这个
日志仅当下载单 torrent 的时候有用, 否则偏移量将不唯一.</font></p>
<p>In order to easily plot this directly in gnuplot, without parsing it, there are two lines
associated with each read or write operation. The first one is the offset where the operation
started, and the second one is where the operation ended.</p>
<p><font color="#0000E3">为了更简单的使用 gnuplot 来直接布局, 不用去解析它, 每次读取或者写入操作会关联到两行日志中. 
  第一行是本次操作开始的偏移量, 然后第二行是本次操作结束的偏移量.</font></p>
<p>Example:</p>
<p><font color="#0000E3">例如:</font></p>
<pre class="literal-block">
15437 read 301187072
15437 read_end 301203456
16651 read 213385216
16680 read_end 213647360
25879 write 249036800
25879 write_end 249298944
26811 read 325582848
26943 read_end 325844992
36736 read 367001600
36766 read_end 367263744
</pre>
<p>The disk access log does not have any good visualization tool yet. There is however a gnuplot
file, <tt class="docutils literal">disk_access.gnuplot</tt> which assumes <tt class="docutils literal">disk_access.log</tt> is in the current directory.</p>
<p><font color="#0000E3">磁盘访问日志目前并没有友的可视化工具. 只是一个 gnuplot
文件, <tt class="docutils literal">disk_access.gnuplot</tt> 假定 <tt class="docutils literal">disk_access.log</tt> 在当前目录.</font></p>
<img alt="disk_access.png" src="disk_access.png" />
<p>The density of the disk seeks tells you how hard the drive has to work.</p>
<p><font color="#0000E3">磁盘寻道的密集程度说明了磁盘的工作强度.</font></p>
</div>
</div>
<div class="section" id="session-stats">
<h2>session stats(会话状态)</h2>
<p>By defining <tt class="docutils literal">TORRENT_STATS</tt> libtorrent will write a log file called <tt class="docutils literal"><span class="pre">session_stats/&lt;pid&gt;.&lt;sequence&gt;.log</span></tt> which
is in a format ready to be passed directly into gnuplot. The parser script <tt class="docutils literal">parse_session_stats.py</tt>
generates a report in <tt class="docutils literal">session_stats_report/index.html</tt>.</p>
<p><font color="#0000E3">通过定义 <tt class="docutils literal">TORRENT_STATS</tt> libtorrent 会写入一个叫做 <tt class="docutils literal"><span class="pre">session_stats/&lt;pid&gt;.&lt;sequence&gt;.log</span></tt> 的日志文件，它
的格式直接适用于 gnuplot. 解析脚本 <tt class="docutils literal">parse_session_stats.py</tt>
会生成一个报告于 <tt class="docutils literal">session_stats_report/index.html</tt> 中.</font></p>
<p>The first line in the log contains all the field names, separated by colon:</p>
<p><font color="#0000E3">日止的第一行包含所有的字段名称, 以冒号分隔:</font></p>
<pre class="literal-block">
second:upload rate:download rate:downloading torrents:seeding torrents:peers...
</pre>
<p>The rest of the log is one line per second with all the fields' values.</p>
<p><font color="#0000E3">其余日志每秒产生一行，这一行包括所有字段的值.</font></p>
<p>These are the fields:</p>
<p><font color="#0000E3">字段如下:</font></p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">field name</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>second</td>
<td>the time, in seconds, for this log line</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">时间, 秒数, 对应一行日志</font></td>
</tr>
<tr><td>upload rate</td>
<td>the number of bytes uploaded in the last second</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">最后一秒上传的字节数</font></td>
</tr>
<tr><td>download rate</td>
<td>the number of bytes downloaded in the last second</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">最后一秒下载的字节数</font></td>
</tr>
<tr><td>downloading torrents</td>
<td>the number of torrents that are not seeds</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">非种子的 torrents 数量</font></td>
</tr>
<tr><td>seeding torrents</td>
<td>the number of torrents that are seed</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">做种的 torrents 数量</font></td>
</tr>
<tr><td>peers</td>
<td>the total number of connected peers</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">已连接的 peers 数量</font></td>
</tr>
<tr><td>connecting peers</td>
<td>the total number of peers attempting to connect (half-open)</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">尝试连接的 peers 数量 (半开连接的)</font></td>
</tr>
<tr><td>disk block buffers</td>
<td>the total number of disk buffer blocks that are in use</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">正在使用的磁盘缓冲块</font></td>
</tr>
<tr><td>unchoked peers</td>
<td>the total number of unchoked peers</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">非阻塞的 peers 数量</font></td>
</tr>
<tr><td>num list peers</td>
<td>the total number of known peers, but not necessarily connected</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">已知的 peers 数量, 但不一定是已连接的</font></td>
</tr>
<tr><td>peer allocations</td>
<td>the total number of allocations for the peer list pool</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">peer 列表池配额</font></td>
</tr>
<tr><td>peer storage bytes</td>
<td>the total number of bytes allocated for the peer list pool</td>
</tr>
<tr><td></td>
<td><font color="#0000E3">peer 列表池配额字节数</font></td>
</tr>
</tbody>
</table>
<p>This is an example of a graph that can be generated from this log:</p>
<p><font color="#0000E3">这是一个可以从日志生成图片的例子:</font></p>
<img alt="session_stats_peers.png" src="session_stats_peers.png" />
<p>It shows statistics about the number of peers and peers states. How at the startup
there are a lot of half-open connections, which tapers off as the total number of
peers approaches the limit (50). It also shows how the total peer list slowly but steadily
grows over time. This list is plotted against the right axis, as it has a different scale
as the other fields.</p>
<p><font color="#0000E3">图中展示了 peers 数量和 peers 状态的统计数据. 启动时有大量的半开连接
, 然后因为达到 peers 数量限制值(50)而逐渐减少. 图中也展示了总体的 peer 列表随着时间缓慢持续地增长. 
这个列表在右边的坐标轴, 因为它的比例尺和其他字段不一样.</font></p>
</div>
</div>
<div class="section" id="understanding-the-disk-thread">
<h1>understanding the disk thread(理解磁盘线程)</h1>
<p>All disk operations are funneled through a separate thread, referred to as the disk thread.
The main interface to the disk thread is a queue where disk jobs are posted, and the results
of these jobs are then posted back on the main thread's io_service.</p>
<p><font color="#0000E3">所有的磁盘操作全由一个单独的线程来完成, 所谓的磁盘线程.
磁盘线程的主要接口是一个可以投递任务的队列, 然后这些任务的结果
会被投递回主线程的 io_service.</font></p>
<p>A disk job is essentially one of:</p>
<p><font color="#0000E3">磁盘任务本质上是:</font></p>
<ol class="arabic simple">
<li>write this block to disk, i.e. a write job. For the most part this is just a matter of sticking the block in the disk cache, but if we've run out of cache space or completed a whole piece, we'll also flush blocks to disk. This is typically very fast, since the OS just sticks these buffers in its write cache which will be flushed at a later time, presumably when the drive head will pass the place on the platter where the blocks go.</li>
<p><font color="#0000E3">写入分块到磁盘, i.e. 写操作. 基本上这只是持久化磁盘缓存中分块的事, 但是一旦我们超出缓存空间大小或者下载完成一个分片, 我们也会将分块刷到磁盘. 这通常很快, 因为操作系统只是在写入缓存中持久化这些缓冲区然后随后刷到磁盘, 大概是当磁头经过分块所在扇区时.</font></p>
<li>read this block from disk. The first thing that happens is we look in the cache to see if the block is already in RAM. If it is, we'll return immediately with this block. If it's a cache miss, we'll have to hit the disk. Here we decide to defer this job. We find the physical offset on the drive for this block and insert the job in an ordere queue, sorted by the physical location. At a later time, once we don't have any more non-read jobs left in the queue, we pick one read job out of the ordered queue and service it. The order we pick jobs out of the queue is according to an elevator cursor moving up and down along the ordered queue of read jobs. If we have enough space in the cache we'll read read_cache_line_size number of blocks and stick those in the cache. This defaults to 32 blocks.</li>
<p><font color="#0000E3">从磁盘读取分块. 首先会发生的事是先看下分块是不是已经在内存中. 如果是, 我们会立即返回该分块. 如果没有, 我们回去磁盘中取. 这就是我们打算要定义的任务. 我们查找这个分块在驱动器的物理偏移然后将这个任务插入到一个有序队列中, 按物理位置排序. 过一段时间后, 当队列中没有非读取的任务时, 我们会从这个有序队列中取出一个读取任务然后执行该任务. 我们从队列中取任务的顺序是通过一个在这个有序的读取任务的队列中上下移动的光标来完成的. 如果缓存中有足够的空间， 则会读取 read_cache_line_size 数量的分块然后把它们保留在缓存中. 默认是32个分块.</font></p>
</ol>
<p>Other disk job consist of operations that needs to be synchronized with the disk I/O, like renaming files, closing files, flushing the cache, updating the settings etc. These are relatively rare though.</p>
<p><font color="#0000E3">其它磁盘任务包括操作需要和磁盘 I/O 进行同步, 例如重命名文件, 关闭文件, 刷缓存, 更新设置等. 这些虽然比较少见.</font></p>
</div>
<div class="section" id="contributions">
<h1>contributions(贡献)</h1>
<p>If you have added instrumentation for some part of libtorrent that is not covered here, or
if you have improved any of the parser scrips, please consider contributing it back to the
project.</p>
<p><font color="#0000E3">如果你增加了 libtorrent 的某些说明但是还没覆盖到这里, 或者
你优化了解析脚本, 欢迎贡献到这个项目中来.</font></p>
<p>If you have run tests and found that some algorithm or default value in libtorrent is
suboptimal, please contribute that knowledge back as well, to allow us to improve the library.</p>
<p><font color="#0000E3">如果你运行了一些测试然后发现 libtorrent 中一些算法或者默认值不是最优的, 请反馈回来, 让我们来优化这个库.</font></p>
<p>If you have additional suggestions on how to tune libtorrent for any specific use case,
please let us know and we'll update this document.</p>
<p><font color="#0000E3">如果你有其他关于如何在任何特定使用场景下调优 libtorrent 的建议, 请告知我们, 我们会完善文档.</font></p>
</div>

    </div>
    </div>
    <div id="gradient"></div>
    <div id="footer">
    <table>
    <tr>
      <td><a href="index.html">home</a></td>
      <td><a href="http://blog.libtorrent.org">blog</a></td>
      <td><a href="utp.html">uTP</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/libtorrent/">download</a></td>
      <td><a href="reference.html">documentation</a></td>
      <td><a href="dht_store.html">DHT put extension</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/py-libtorrent/">python bindings</a></td>
      <td><a href="features.html">features</a></td>
      <td><a href="dht_sec.html">DHT security extension</a></td>
    </tr>
    <tr>
      <td><a href="http://dir.gmane.org/gmane.network.bit-torrent.libtorrent">mailing list archive</a></td>
      <td><a href="contributing.html">contributing</a></td>
      <td><a href="streaming.html">streaming</a></td>
    </tr>
    <tr>
      <td><a href="http://code.google.com/p/libtorrent/issues/entry">report a bug</a></td>
      <td><a href="building.html">building</a></td>
      <td><a href="bittorrent.pdf">bittorrent slides</a></td>
    </tr>
    </table>
    </div>
    <div id="filler"></div>

</div>
</body>
</html>
